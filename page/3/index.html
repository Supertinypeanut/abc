<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Peanut</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Peanut">
<meta property="og:url" content="https://supertinypeanut.github.io/blog/page/3/index.html">
<meta property="og:site_name" content="Peanut">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Super Peanut">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/blog/atom.xml" title="Peanut" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/blog/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">Peanut</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/blog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://supertinypeanut.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-es6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/02/21/es6/" class="article-date">
  <time datetime="2020-02-21T10:10:10.000Z" itemprop="datePublished">2020-02-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/02/21/es6/">ES6 特性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文的知识点完全是参考或摘录《ES6》里的语句，有部分语句为了方便理解和记忆，进行了相同意思的转义，同时对知识点进行归类划分。为了让大家能集中精力来记住这些特性，全文一句废话和题外话都没有，全部模块以笔记的形式进行书写，如果看得不是很惯建议对照《ES6》的内容来学习。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以下提到的《ECMAScript <span class="number">6</span> 入门》统一使用《ES6》这个名称来代替，而最新的ES6版本也是截止到当前的ES2019</span><br></pre></td></tr></table></figure>

<p>本文整理出来的笔记都是书中的精华内容，囊括了整个<code>ES6体系</code>的所有特性，非常方便大家重新认识<code>全部ES6特性</code>。半小时的阅读就可以对<code>ES6</code>有一个全面的了解，可以认为是一本<code>ES6特性小字典</code>。</p>
<p><img src="/blog/.io//640.jpeg" alt="img"></p>
<h3 id="修正"><a href="#修正" class="headerlink" title="修正"></a>修正</h3><p><strong>ES6</strong>是<code>ECMA</code>为<code>JavaScript</code>制定的第6个标准版本，相关历史可查看此章节《ES6-ECMAScript6简介》。</p>
<p>标准委员会最终决定，标准在每年6月正式发布并作为当年的正式版本，接下来的时间里就在此版本的基础上进行改动，直到下一年6月草案就自然变成新一年的版本，这样一来就无需以前的版本号，只要用年份标记即可。<code>ECMAscript 2015</code>是在<code>2015年6月</code>发布ES6的第一个版本。以此类推，<code>ECMAscript 2016</code>是ES6的第二个版本、 <code>ECMAscript 2017</code>是ES6的第三个版本。<strong>ES6</strong>既是一个历史名词也是一个泛指，含义是<code>5.1版本</code>以后的<code>JavaScript下一代标准</code>，目前涵盖了<code>ES2015</code>、<code>ES2016</code>、<code>ES2017</code>、<code>ES2018</code>、<code>ES2019</code>。</p>
<p>所以有些文章上提到的<code>ES7</code>(实质上是<code>ES2016</code>)、<code>ES8</code>(实质上是<code>ES2017</code>)、<code>ES9</code>(实质上是<code>ES2018</code>)、<code>ES10</code>(实质上是<code>ES2019</code>)，实质上都是一些不规范的概念。从ES1到ES6，每个标准都是花了好几年甚至十多年才制定下来，你一个ES6到ES7，ES7到ES8，才用了一年，按照这样的定义下去，那不是很快就ES20了。用正确的概念来说ES6目前涵盖了<strong>ES2015</strong>(ES6.0)、<strong>ES2016</strong>(ES6.1)、<strong>ES2017</strong>(ES6.2)、<strong>ES2018</strong>(ES6.3)、<strong>ES2019</strong>(ES6.4)。</p>
<p>另外，ES6更新的内容主要分为以下几点</p>
<ul>
<li><strong>表达式</strong>：声明、解构赋值</li>
<li><strong>内置对象</strong>：字符串扩展、数值扩展、对象扩展、数组扩展、函数扩展、正则扩展、Symbol、Set、Map、Proxy、Reflect</li>
<li><strong>语句与运算</strong>：Class、Module、Iterator</li>
<li><strong>异步编程</strong>：Promise、Generator、Async</li>
</ul>
<h2 id="ES2015"><a href="#ES2015" class="headerlink" title="ES2015"></a>ES2015</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><ul>
<li><input checked disabled type="checkbox"> <strong>const命令</strong>：声明常量</li>
<li><input checked disabled type="checkbox"> <strong>let命令</strong>：声明变量</li>
</ul>
<blockquote>
<p>作用</p>
</blockquote>
<ul>
<li><p>作用域</p>
</li>
<li><ul>
<li><strong>全局作用域</strong></li>
<li><strong>函数作用域</strong>：<code>function() {}</code></li>
<li><strong>块级作用域</strong>：<code>{}</code></li>
</ul>
</li>
<li><p>作用范围</p>
</li>
<li><ul>
<li><code>var</code>在全局代码中执行</li>
<li><code>const</code>和<code>let</code>只能在代码块中执行</li>
</ul>
</li>
<li><p>赋值使用</p>
</li>
<li><ul>
<li><code>const</code>声明常量后必须立马赋值</li>
<li><code>let</code>声明变量后可立马赋值或使用时赋值</li>
</ul>
</li>
<li><p>声明方法：<code>var</code>、<code>const</code>、<code>let</code>、<code>function</code>、<code>class</code>、<code>import</code></p>
</li>
</ul>
<blockquote>
<p>重点难点</p>
</blockquote>
<ul>
<li>不允许重复声明</li>
<li>未定义就使用会报错：<code>const</code>和<code>let</code>不存在变量提升</li>
<li>暂时性死区：只要块级作用域内存在<code>const</code>和<code>let</code>，所声明常量和变量就绑定此区域，不再受外部影响</li>
</ul>
<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><ul>
<li><input checked disabled type="checkbox"> <p><strong>字符串解构</strong>：<code>const [a, b, c, d, e] = &quot;hello&quot;</code></p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>数值解构</strong>：<code>const { toString: s } = 123</code></p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>布尔值解构</strong>：<code>const { toString: b } = true</code></p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>对象解构</strong></p>
</li>
<li><ul>
<li>形式：<code>const { x, y } = { x: 1, y: 2 }</code></li>
<li>默认：<code>const { x, y = 2 } = { x: 1 }</code></li>
<li>改名：<code>const { x, y: z } = { x: 1, y: 2 }</code></li>
</ul>
</li>
<li><input checked disabled type="checkbox"> <p><strong>数组解构</strong></p>
</li>
<li><ul>
<li>规则：数据结构具有<code>Iterator接口</code>可采用数组形式的解构赋值</li>
<li>形式：<code>const [x, y] = [1, 2]</code></li>
<li>默认：<code>const [x, y = 2] = [1]</code></li>
</ul>
</li>
<li><input checked disabled type="checkbox"> <p><strong>函数参数解构</strong></p>
</li>
<li><ul>
<li>数组解构：<code>function Func([x = 0, y = 1]) {}</code></li>
<li>对象解构：<code>function Func({ x = 0, y = 1 } = {}) {}</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>应用场景</p>
</blockquote>
<ul>
<li>交换变量值：<code>[x, y] = [y, x]</code></li>
<li>返回函数多个值：<code>const [x, y, z] = Func()</code></li>
<li>定义函数参数：<code>Func([1, 2])</code></li>
<li>提取JSON数据：<code>const { name, version } = packageJson</code></li>
<li>定义函数参数默认值：<code>function Func({ x = 1, y = 2 } = {}) {}</code></li>
<li>遍历Map结构：<code>for (let [k, v] of Map) {}</code></li>
<li>输入模块指定属性和方法：<code>const { readFile, writeFile } = require(&quot;fs&quot;)</code></li>
</ul>
<blockquote>
<p>重点难点</p>
</blockquote>
<ul>
<li>匹配模式：只要等号两边的模式相同，左边的变量就会被赋予对应的值</li>
<li>解构赋值规则：只要等号右边的值不是对象或数组，就先将其转为对象</li>
<li>解构默认值生效条件：属性值严格等于<code>undefined</code></li>
<li>解构遵循匹配模式</li>
<li>解构不成功时变量的值等于<code>undefined</code></li>
<li><code>undefined</code>和<code>null</code>无法转为对象，因此无法进行解构</li>
</ul>
<h3 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h3><ul>
<li><input checked disabled type="checkbox"> <strong>Unicode表示法</strong>：<code>大括号包含</code>表示Unicode字符(<code>\u{0xXX}</code>或<code>\u{0XXX}</code>)</li>
<li><input checked disabled type="checkbox"> <strong>字符串遍历</strong>：可通过<code>for-of</code>遍历字符串</li>
<li><input checked disabled type="checkbox"> <strong>字符串模板</strong>：可单行可多行可插入变量的增强版字符串</li>
<li><input checked disabled type="checkbox"> <strong>标签模板</strong>：函数参数的特殊调用</li>
<li><input checked disabled type="checkbox"> <strong>String.raw()</strong>：返回把字符串所有变量替换且对斜杠进行转义的结果</li>
<li><input checked disabled type="checkbox"> <strong>String.fromCodePoint()</strong>：返回码点对应字符</li>
<li><input checked disabled type="checkbox"> <strong>codePointAt()</strong>：返回字符对应码点(<code>String.fromCodePoint()</code>的逆操作)</li>
<li><input checked disabled type="checkbox"> <strong>normalize()</strong>：把字符的不同表示方法统一为同样形式，返回<code>新字符串</code>(Unicode正规化)</li>
<li><input checked disabled type="checkbox"> <strong>repeat()</strong>：把字符串重复n次，返回<code>新字符串</code></li>
<li><input checked disabled type="checkbox"> <strong>matchAll()</strong>：返回正则表达式在字符串的所有匹配</li>
<li><input checked disabled type="checkbox"> <strong>includes()</strong>：是否存在指定字符串</li>
<li><input checked disabled type="checkbox"> <strong>startsWith()</strong>：是否存在字符串头部指定字符串</li>
<li><input checked disabled type="checkbox"> <strong>endsWith()</strong>：是否存在字符串尾部指定字符串</li>
</ul>
<blockquote>
<p>重点难点</p>
</blockquote>
<ul>
<li>以上扩展方法均可作用于由<code>4个字节储存</code>的<code>Unicode字符</code>上</li>
</ul>
<h3 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h3><ul>
<li><input checked disabled type="checkbox"> <strong>二进制表示法</strong>：<code>0b或0B开头</code>表示二进制(<code>0bXX</code>或<code>0BXX</code>)</li>
<li><input checked disabled type="checkbox"> <strong>八进制表示法</strong>：<code>0o或0O开头</code>表示二进制(<code>0oXX</code>或<code>0OXX</code>)</li>
<li><input checked disabled type="checkbox"> <strong>Number.EPSILON</strong>：数值最小精度</li>
<li><input checked disabled type="checkbox"> <strong>Number.MIN_SAFE_INTEGER</strong>：最小安全数值(<code>-2^53</code>)</li>
<li><input checked disabled type="checkbox"> <strong>Number.MAX_SAFE_INTEGER</strong>：最大安全数值(<code>2^53</code>)</li>
<li><input checked disabled type="checkbox"> <strong>Number.parseInt()</strong>：返回转换值的整数部分</li>
<li><input checked disabled type="checkbox"> <strong>Number.parseFloat()</strong>：返回转换值的浮点数部分</li>
<li><input checked disabled type="checkbox"> <strong>Number.isFinite()</strong>：是否为有限数值</li>
<li><input checked disabled type="checkbox"> <strong>Number.isNaN()</strong>：是否为NaN</li>
<li><input checked disabled type="checkbox"> <strong>Number.isInteger()</strong>：是否为整数</li>
<li><input checked disabled type="checkbox"> <strong>Number.isSafeInteger()</strong>：是否在数值安全范围内</li>
<li><input checked disabled type="checkbox"> <strong>Math.trunc()</strong>：返回数值整数部分</li>
<li><input checked disabled type="checkbox"> <strong>Math.sign()</strong>：返回数值类型(<code>正数1</code>、<code>负数-1</code>、<code>零0</code>)</li>
<li><input checked disabled type="checkbox"> <strong>Math.cbrt()</strong>：返回数值立方根</li>
<li><input checked disabled type="checkbox"> <strong>Math.clz32()</strong>：返回数值的32位无符号整数形式</li>
<li><input checked disabled type="checkbox"> <strong>Math.imul()</strong>：返回两个数值相乘</li>
<li><input checked disabled type="checkbox"> <strong>Math.fround()</strong>：返回数值的32位单精度浮点数形式</li>
<li><input checked disabled type="checkbox"> <strong>Math.hypot()</strong>：返回所有数值平方和的平方根</li>
<li><input checked disabled type="checkbox"> <strong>Math.expm1()</strong>：返回<code>e^n - 1</code></li>
<li><input checked disabled type="checkbox"> <strong>Math.log1p()</strong>：返回<code>1 + n</code>的自然对数(<code>Math.log(1 + n)</code>)</li>
<li><input checked disabled type="checkbox"> <strong>Math.log10()</strong>：返回以10为底的n的对数</li>
<li><input checked disabled type="checkbox"> <strong>Math.log2()</strong>：返回以2为底的n的对数</li>
<li><input checked disabled type="checkbox"> <strong>Math.sinh()</strong>：返回n的双曲正弦</li>
<li><input checked disabled type="checkbox"> <strong>Math.cosh()</strong>：返回n的双曲余弦</li>
<li><input checked disabled type="checkbox"> <strong>Math.tanh()</strong>：返回n的双曲正切</li>
<li><input checked disabled type="checkbox"> <strong>Math.asinh()</strong>：返回n的反双曲正弦</li>
<li><input checked disabled type="checkbox"> <strong>Math.acosh()</strong>：返回n的反双曲余弦</li>
<li><input checked disabled type="checkbox"> <strong>Math.atanh()</strong>：返回n的反双曲正切</li>
</ul>
<h3 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h3><ul>
<li><input checked disabled type="checkbox"> <p><strong>简洁表示法</strong>：直接写入变量和函数作为对象的属性和方法(<code>{ prop, method() {} }</code>)</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>属性名表达式</strong>：字面量定义对象时使用<code>[]</code>定义键(<code>[prop]</code>，不能与上同时使用)</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>方法的name属性</strong>：返回方法函数名</p>
</li>
<li><ul>
<li>取值函数(getter)和存值函数(setter)：<code>get/set 函数名</code>(属性的描述对象在<code>get</code>和<code>set</code>上)</li>
<li>bind返回的函数：<code>bound 函数名</code></li>
<li>Function构造函数返回的函数实例：<code>anonymous</code></li>
</ul>
</li>
<li><input checked disabled type="checkbox"> <p><strong>属性的可枚举性和遍历</strong>：描述对象的<code>enumerable</code></p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>super关键字</strong>：指向当前对象的原型对象(只能用在对象的简写方法中<code>method() {}</code>)</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>Object.is()</strong>：对比两值是否相等</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>Object.assign()</strong>：合并对象(浅拷贝)，返回原对象</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>Object.getPrototypeOf()</strong>：返回对象的原型对象</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>Object.setPrototypeOf()</strong>：设置对象的原型对象</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong><strong>proto</strong></strong>：返回或设置对象的原型对象</p>
</li>
</ul>
<blockquote>
<p>属性遍历</p>
</blockquote>
<ul>
<li><p>描述：<code>自身</code>、<code>可继承</code>、<code>可枚举</code>、<code>非枚举</code>、<code>Symbol</code></p>
</li>
<li><p>遍历</p>
</li>
<li><ul>
<li><code>for-in</code>：遍历对象<code>自身可继承可枚举</code>属性</li>
<li><code>Object.keys()</code>：返回对象<code>自身可枚举</code>属性的键组成的数组</li>
<li><code>Object.getOwnPropertyNames()</code>：返回对象<code>自身可继承可枚举非枚举</code>属性的键组成的数组</li>
<li><code>Object.getOwnPropertySymbols()</code>：返回对象<code>Symbol</code>属性的键组成的数组</li>
<li><code>Reflect.ownKeys()</code>：返回对象<code>自身可继承可枚举非枚举Symbol</code>属性的键组成的数组</li>
</ul>
</li>
<li><p>规则</p>
</li>
<li><ul>
<li>首先遍历所有数值键，按照数值升序排列</li>
<li>其次遍历所有字符串键，按照加入时间升序排列</li>
<li>最后遍历所有Symbol键，按照加入时间升序排列</li>
</ul>
</li>
</ul>
<h3 id="数组扩展"><a href="#数组扩展" class="headerlink" title="数组扩展"></a>数组扩展</h3><ul>
<li><input checked disabled type="checkbox"> <p><strong>扩展运算符(…)</strong>：转换数组为用逗号分隔的参数序列(<code>[...arr]</code>，相当于<code>rest/spread参数</code>的逆运算)</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>Array.from()</strong>：转换具有<code>Iterator接口</code>的数据结构为真正数组，返回新数组</p>
</li>
<li><ul>
<li>类数组对象：<code>包含length的对象</code>、<code>Arguments对象</code>、<code>NodeList对象</code></li>
<li>可遍历对象：<code>String</code>、<code>Set结构</code>、<code>Map结构</code>、<code>Generator函数</code></li>
</ul>
</li>
<li><input checked disabled type="checkbox"> <p><strong>Array.of()</strong>：转换一组值为真正数组，返回新数组</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>copyWithin()</strong>：把指定位置的成员复制到其他位置，返回原数组</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>find()</strong>：返回第一个符合条件的成员</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>findIndex()</strong>：返回第一个符合条件的成员索引值</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>fill()</strong>：根据指定值填充整个数组，返回原数组</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>keys()</strong>：返回以索引值为遍历器的对象</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>values()</strong>：返回以属性值为遍历器的对象</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>entries()</strong>：返回以索引值和属性值为遍历器的对象</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>数组空位</strong>：ES6明确将数组空位转为<code>undefined</code>(空位处理规不一，建议避免出现)</p>
</li>
</ul>
<blockquote>
<p>扩展应用</p>
</blockquote>
<ul>
<li>克隆数组：<code>const arr = [...arr1]</code></li>
<li>合并数组：<code>const arr = [...arr1, ...arr2]</code></li>
<li>拼接数组：<code>arr.push(...arr1)</code></li>
<li>代替apply：<code>Math.max.apply(null, [x, y])</code> =&gt; <code>Math.max(...[x, y])</code></li>
<li>转换字符串为数组：<code>[...&quot;hello&quot;]</code></li>
<li>转换类数组对象为数组：<code>[...Arguments, ...NodeList]</code></li>
<li>转换可遍历对象为数组：<code>[...String, ...Set, ...Map, ...Generator]</code></li>
<li>与数组解构赋值结合：<code>const [x, ...rest/spread] = [1, 2, 3]</code></li>
<li>计算Unicode字符长度：<code>Array.from(&quot;hello&quot;).length</code> =&gt; <code>[...&quot;hello&quot;].length</code></li>
</ul>
<blockquote>
<p>重点难点</p>
</blockquote>
<ul>
<li>使用<code>keys()</code>、<code>values()</code>、<code>entries()</code>返回的遍历器对象，可用<code>for-of</code>自动遍历或<code>next()</code>手动遍历</li>
</ul>
<h3 id="函数扩展"><a href="#函数扩展" class="headerlink" title="函数扩展"></a>函数扩展</h3><ul>
<li><input checked disabled type="checkbox"> <p><strong>参数默认值</strong>：为函数参数指定默认值</p>
</li>
<li><ul>
<li>指定某个参数不得省略，省略即抛出错误：<code>function Func(x = throwMissing()) {}</code></li>
<li>将参数默认值设为<code>undefined</code>，表明此参数可省略：<code>Func(undefined, 1)</code></li>
<li>形式：<code>function Func(x = 1, y = 2) {}</code></li>
<li>参数赋值：惰性求值(函数调用后才求值)</li>
<li>参数位置：尾参数</li>
<li>参数作用域：函数作用域</li>
<li>声明方式：默认声明，不能用<code>const</code>或<code>let</code>再次声明</li>
<li>length：返回没有指定默认值的参数个数</li>
<li>与解构赋值默认值结合：<code>function Func({ x = 1, y = 2 } = {}) {}</code></li>
<li>应用</li>
</ul>
</li>
<li><input checked disabled type="checkbox"> <p><strong>rest/spread参数(…)</strong>：返回函数多余参数</p>
</li>
<li><ul>
<li>形式：以数组的形式存在，之后不能再有其他参数</li>
<li>作用：代替<code>Arguments对象</code></li>
<li>length：返回没有指定默认值的参数个数但不包括<code>rest/spread参数</code></li>
</ul>
</li>
<li><input checked disabled type="checkbox"> <p><strong>严格模式</strong>：在严格条件下运行JS</p>
</li>
<li><ul>
<li>应用：只要函数参数使用默认值、解构赋值、扩展运算符，那么函数内部就不能显式设定为严格模式</li>
</ul>
</li>
<li><input checked disabled type="checkbox"> <p><strong>name属性</strong>：返回函数的函数名</p>
</li>
<li><ul>
<li>将匿名函数赋值给变量：<code>空字符串</code>(<strong>ES5</strong>)、<code>变量名</code>(<strong>ES6</strong>)</li>
<li>将具名函数赋值给变量：<code>函数名</code>(<strong>ES5和ES6</strong>)</li>
<li>bind返回的函数：<code>bound 函数名</code>(<strong>ES5和ES6</strong>)</li>
<li>Function构造函数返回的函数实例：<code>anonymous</code>(<strong>ES5和ES6</strong>)</li>
</ul>
</li>
<li><input checked disabled type="checkbox"> <p><strong>箭头函数(=&gt;)</strong>：函数简写</p>
</li>
<li><ul>
<li>并非因为内部有绑定<code>this</code>的机制，而是根本没有自己的<code>this</code>，导致内部的<code>this</code>就是外层代码块的<code>this</code></li>
<li>因为没有<code>this</code>，因此不能用作构造函数</li>
<li>无参数：<code>() =&gt; {}</code></li>
<li>单个参数：<code>x =&gt; {}</code></li>
<li>多个参数：<code>(x, y) =&gt; {}</code></li>
<li>解构参数：<code>({x, y}) =&gt; {}</code></li>
<li>嵌套使用：部署管道机制</li>
<li>this指向固定化</li>
</ul>
</li>
<li><input checked disabled type="checkbox"> <p><strong>尾调用优化</strong>：只保留内层函数的调用帧</p>
</li>
<li><ul>
<li>定义：函数尾调用自身</li>
<li>作用：只要使用尾递归就不会发生栈溢出，相对节省内存</li>
<li>实现：把所有用到的内部变量改写成函数的参数并使用参数默认值</li>
<li>定义：某个函数的最后一步是调用另一个函数</li>
<li>形式：<code>function f(x) { return g(x); }</code></li>
<li>尾调用</li>
<li>尾递归</li>
</ul>
</li>
</ul>
<blockquote>
<p>箭头函数误区</p>
</blockquote>
<ul>
<li>函数体内的<code>this</code>是<code>定义时所在的对象</code>而不是<code>使用时所在的对象</code></li>
<li>可让<code>this</code>指向固定化，这种特性很有利于封装回调函数</li>
<li>不可当作<code>构造函数</code>，因此箭头函数不可使用<code>new命令</code></li>
<li>不可使用<code>yield命令</code>，因此箭头函数不能用作<code>Generator函数</code></li>
<li>不可使用<code>Arguments对象</code>，此对象在函数体内不存在(可用<code>rest/spread参数</code>代替)</li>
<li>返回对象时必须在对象外面加上括号</li>
</ul>
<h3 id="正则扩展"><a href="#正则扩展" class="headerlink" title="正则扩展"></a>正则扩展</h3><ul>
<li><input checked disabled type="checkbox"> <p><strong>变更RegExp构造函数入参</strong>：允许首参数为<code>正则对象</code>，尾参数为<code>正则修饰符</code>(返回的正则表达式会忽略原正则表达式的修饰符)</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>正则方法调用变更</strong>：字符串对象的<code>match()</code>、<code>replace()</code>、<code>search()</code>、<code>split()</code>内部调用转为调用<code>RegExp</code>实例对应的<code>RegExp.prototype[Symbol.方法]</code></p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>u修饰符</strong>：Unicode模式修饰符，正确处理大于<code>\uFFFF</code>的<code>Unicode字符</code></p>
</li>
<li><ul>
<li><code>点字符</code>(.)</li>
<li><code>Unicode表示法</code></li>
<li><code>量词</code></li>
<li><code>预定义模式</code></li>
<li><code>i修饰符</code></li>
<li><code>转义</code></li>
</ul>
</li>
<li><input checked disabled type="checkbox"> <p><strong>y修饰符</strong>：粘连修饰符，确保匹配必须从剩余的第一个位置开始全局匹配(与<code>g修饰符</code>作用类似)</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>unicode</strong>：是否设置<code>u修饰符</code></p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>sticky</strong>：是否设置<code>y修饰符</code></p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>flags</strong>：正则表达式的修饰符</p>
</li>
</ul>
<blockquote>
<p>重点难点</p>
</blockquote>
<ul>
<li><code>y修饰符</code>隐含头部匹配标志<code>^</code></li>
<li>单单一个<code>y修饰符</code>对<code>match()</code>只能返回第一个匹配，必须与<code>g修饰符</code>联用才能返回所有匹配</li>
</ul>
<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><ul>
<li><p>定义：独一无二的值</p>
</li>
<li><p>声明：<code>const set = Symbol(str)</code></p>
</li>
<li><p>入参：字符串(可选)</p>
</li>
<li><p>方法</p>
</li>
<li><ul>
<li><strong>Symbol()</strong>：创建以参数作为描述的<code>Symbol值</code>(不登记在全局环境)</li>
<li><strong>Symbol.for()</strong>：创建以参数作为描述的<code>Symbol值</code>，如存在此参数则返回原有的<code>Symbol值</code>(先搜索后创建，登记在全局环境)</li>
<li><strong>Symbol.keyFor()</strong>：返回已登记的<code>Symbol值</code>的描述(只能返回<code>Symbol.for()</code>的<code>key</code>)</li>
<li><strong>Object.getOwnPropertySymbols()</strong>：返回对象中所有用作属性名的<code>Symbol值</code>的数组</li>
</ul>
</li>
<li><p>内置</p>
</li>
<li><ul>
<li><strong>Symbol.hasInstance</strong>：指向一个内部方法，当其他对象使用<code>instanceof运算符</code>判断是否为此对象的实例时会调用此方法</li>
<li><strong>Symbol.isConcatSpreadable</strong>：指向一个布尔值，定义对象用于<code>Array.prototype.concat()</code>时是否可展开</li>
<li><strong>Symbol.species</strong>：指向一个构造函数，当实例对象使用自身构造函数时会调用指定的构造函数</li>
<li><strong>Symbol.match</strong>：指向一个函数，当实例对象被<code>String.prototype.match()</code>调用时会重新定义<code>match()</code>的行为</li>
<li><strong>Symbol.replace</strong>：指向一个函数，当实例对象被<code>String.prototype.replace()</code>调用时会重新定义<code>replace()</code>的行为</li>
<li><strong>Symbol.search</strong>：指向一个函数，当实例对象被<code>String.prototype.search()</code>调用时会重新定义<code>search()</code>的行为</li>
<li><strong>Symbol.split</strong>：指向一个函数，当实例对象被<code>String.prototype.split()</code>调用时会重新定义<code>split()</code>的行为</li>
<li><strong>Symbol.iterator</strong>：指向一个默认遍历器方法，当实例对象执行<code>for-of</code>时会调用指定的默认遍历器</li>
<li><strong>Symbol.toPrimitive</strong>：指向一个函数，当实例对象被转为原始类型的值时会返回此对象对应的原始类型值</li>
<li><strong>Symbol.toStringTag</strong>：指向一个函数，当实例对象被<code>Object.prototype.toString()</code>调用时其返回值会出现在<code>toString()</code>返回的字符串之中表示对象的类型</li>
<li><strong>Symbol.unscopables</strong>：指向一个对象，指定使用<code>with</code>时哪些属性会被<code>with环境</code>排除</li>
</ul>
</li>
</ul>
<blockquote>
<p>数据类型</p>
</blockquote>
<ul>
<li><strong>Undefined</strong></li>
<li><strong>Null</strong></li>
<li><strong>String</strong></li>
<li><strong>Number</strong></li>
<li><strong>Boolean</strong></li>
<li><strong>Object</strong>(包含<code>Array</code>、<code>Function</code>、<code>Date</code>、<code>RegExp</code>、<code>Error</code>)</li>
<li><strong>Symbol</strong></li>
</ul>
<blockquote>
<p>应用场景</p>
</blockquote>
<ul>
<li>唯一化对象属性名：属性名属于Symbol类型，就都是独一无二的，可保证不会与其他属性名产生冲突</li>
<li>消除魔术字符串：在代码中多次出现且与代码形成强耦合的某一个具体的字符串或数值</li>
<li>遍历属性名：无法通过<code>for-in</code>、<code>for-of</code>、<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回，只能通过<code>Object.getOwnPropertySymbols</code>返回</li>
<li>启用模块的Singleton模式：调用一个类在任何时候返回同一个实例(<code>window</code>和<code>global</code>)，使用<code>Symbol.for()</code>来模拟全局的<code>Singleton模式</code></li>
</ul>
<blockquote>
<p>重点难点</p>
</blockquote>
<ul>
<li><code>Symbol()</code>生成一个原始类型的值不是对象，因此<code>Symbol()</code>前不能使用<code>new命令</code></li>
<li><code>Symbol()</code>参数表示对当前<code>Symbol值</code>的描述，相同参数的<code>Symbol()</code>返回值不相等</li>
<li><code>Symbol值</code>不能与其他类型的值进行运算</li>
<li><code>Symbol值</code>可通过<code>String()</code>或<code>toString()</code>显式转为字符串</li>
<li><code>Symbol值</code>作为对象属性名时，此属性是公开属性，但不是私有属性</li>
<li><code>Symbol值</code>作为对象属性名时，只能用方括号运算符(<code>[]</code>)读取，不能用点运算符(<code>.</code>)读取</li>
<li><code>Symbol值</code>作为对象属性名时，不会被常规方法遍历得到，可利用此特性为对象定义<code>非私有但又只用于内部的方法</code></li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h5 id="Set-1"><a href="#Set-1" class="headerlink" title="Set"></a>Set</h5><ul>
<li><p>定义：类似于数组的数据结构，成员值都是唯一且没有重复的值</p>
</li>
<li><p>声明：<code>const set = new Set(arr)</code></p>
</li>
<li><p>入参：具有<code>Iterator接口</code>的数据结构</p>
</li>
<li><p>属性</p>
</li>
<li><ul>
<li><strong>constructor</strong>：构造函数，返回Set</li>
<li><strong>size</strong>：返回实例成员总数</li>
</ul>
</li>
<li><p>方法</p>
</li>
<li><ul>
<li><strong>add()</strong>：添加值，返回实例</li>
<li><strong>delete()</strong>：删除值，返回布尔值</li>
<li><strong>has()</strong>：检查值，返回布尔值</li>
<li><strong>clear()</strong>：清除所有成员</li>
<li><strong>keys()</strong>：返回以属性值为遍历器的对象</li>
<li><strong>values()</strong>：返回以属性值为遍历器的对象</li>
<li><strong>entries()</strong>：返回以属性值和属性值为遍历器的对象</li>
<li><strong>forEach()</strong>：使用回调函数遍历每个成员</li>
</ul>
</li>
</ul>
<blockquote>
<p>应用场景</p>
</blockquote>
<ul>
<li><p>去重字符串：<code>[...new Set(str)].join(&quot;&quot;)</code></p>
</li>
<li><p>去重数组：<code>[...new Set(arr)]</code>或<code>Array.from(new Set(arr))</code></p>
</li>
<li><p>集合数组</p>
</li>
<li><ul>
<li>声明：<code>const a = new Set(arr1)</code>、<code>const b = new Set(arr2)</code></li>
<li>并集：<code>new Set([...a, ...b])</code></li>
<li>交集：<code>new Set([...a].filter(v =&gt; b.has(v)))</code></li>
<li>差集：<code>new Set([...a].filter(v =&gt; !b.has(v)))</code></li>
</ul>
</li>
<li><p>映射集合</p>
</li>
<li><ul>
<li>声明：<code>let set = new Set(arr)</code></li>
<li>映射：<code>set = new Set([...set].map(v =&gt; v * 2))</code>或<code>set = new Set(Array.from(set, v =&gt; v * 2))</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>重点难点</p>
</blockquote>
<ul>
<li>遍历顺序：插入顺序</li>
<li>没有键只有值，可认为键和值两值相等</li>
<li>添加多个<code>NaN</code>时，只会存在一个<code>NaN</code></li>
<li>添加相同的对象时，会认为是不同的对象</li>
<li>添加值时不会发生类型转换(<code>5 !== &quot;5&quot;</code>)</li>
<li><code>keys()</code>和<code>values()</code>的行为完全一致，<code>entries()</code>返回的遍历器同时包括键和值且两值相等</li>
</ul>
<h5 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h5><ul>
<li><p>定义：和Set结构类似，成员值只能是对象</p>
</li>
<li><p>声明：<code>const set = new WeakSet(arr)</code></p>
</li>
<li><p>入参：具有<code>Iterator接口</code>的数据结构</p>
</li>
<li><p>属性</p>
</li>
<li><ul>
<li><strong>constructor</strong>：构造函数，返回WeakSet</li>
</ul>
</li>
<li><p>方法</p>
</li>
<li><ul>
<li><strong>add()</strong>：添加值，返回实例</li>
<li><strong>delete()</strong>：删除值，返回布尔值</li>
<li><strong>has()</strong>：检查值，返回布尔值</li>
</ul>
</li>
</ul>
<blockquote>
<p>应用场景</p>
</blockquote>
<ul>
<li>储存DOM节点：DOM节点被移除时自动释放此成员，不用担心这些节点从文档移除时会引发内存泄漏</li>
<li>临时存放一组对象或存放跟对象绑定的信息：只要这些对象在外部消失，它在<code>WeakSet结构</code>中的引用就会自动消</li>
</ul>
<blockquote>
<p>重点难点</p>
</blockquote>
<ul>
<li>成员都是<code>弱引用</code>，垃圾回收机制不考虑<code>WeakSet结构</code>对此成员的引用</li>
<li>成员不适合引用，它会随时消失，因此ES6规定<code>WeakSet结构不可遍历</code></li>
<li>其他对象不再引用成员时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于<code>WeakSet结构</code>中</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h5 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h5><ul>
<li><p>定义：类似于对象的数据结构，成员键可以是任何类型的值</p>
</li>
<li><p>声明：<code>const set = new Map(arr)</code></p>
</li>
<li><p>入参：具有<code>Iterator接口</code>且每个成员都是一个双元素数组的数据结构</p>
</li>
<li><p>属性</p>
</li>
<li><ul>
<li><strong>constructor</strong>：构造函数，返回Map</li>
<li><strong>size</strong>：返回实例成员总数</li>
</ul>
</li>
<li><p>方法</p>
</li>
<li><ul>
<li><strong>get()</strong>：返回键值对</li>
<li><strong>set()</strong>：添加键值对，返回实例</li>
<li><strong>delete()</strong>：删除键值对，返回布尔值</li>
<li><strong>has()</strong>：检查键值对，返回布尔值</li>
<li><strong>clear()</strong>：清除所有成员</li>
<li><strong>keys()</strong>：返回以键为遍历器的对象</li>
<li><strong>values()</strong>：返回以值为遍历器的对象</li>
<li><strong>entries()</strong>：返回以键和值为遍历器的对象</li>
<li><strong>forEach()</strong>：使用回调函数遍历每个成员</li>
</ul>
</li>
</ul>
<blockquote>
<p>重点难点</p>
</blockquote>
<ul>
<li>遍历顺序：插入顺序</li>
<li>对同一个键多次赋值，后面的值将覆盖前面的值</li>
<li>对同一个对象的引用，被视为一个键</li>
<li>对同样值的两个实例，被视为两个键</li>
<li>键跟内存地址绑定，只要内存地址不一样就视为两个键</li>
<li>添加多个以<code>NaN</code>作为键时，只会存在一个以<code>NaN</code>作为键的值</li>
<li><code>Object结构</code>提供<code>字符串—值</code>的对应，<code>Map结构</code>提供<code>值—值</code>的对应</li>
</ul>
<h5 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h5><ul>
<li><p>定义：和Map结构类似，成员键只能是对象</p>
</li>
<li><p>声明：<code>const set = new WeakMap(arr)</code></p>
</li>
<li><p>入参：具有<code>Iterator接口</code>且每个成员都是一个双元素数组的数据结构</p>
</li>
<li><p>属性</p>
</li>
<li><ul>
<li><strong>constructor</strong>：构造函数，返回WeakMap</li>
</ul>
</li>
<li><p>方法</p>
</li>
<li><ul>
<li><strong>get()</strong>：返回键值对</li>
<li><strong>set()</strong>：添加键值对，返回实例</li>
<li><strong>delete()</strong>：删除键值对，返回布尔值</li>
<li><strong>has()</strong>：检查键值对，返回布尔值</li>
</ul>
</li>
</ul>
<blockquote>
<p>应用场景</p>
</blockquote>
<ul>
<li>储存DOM节点：DOM节点被移除时自动释放此成员键，不用担心这些节点从文档移除时会引发内存泄漏</li>
<li>部署私有属性：内部属性是实例的弱引用，删除实例时它们也随之消失，不会造成内存泄漏</li>
</ul>
<blockquote>
<p>重点难点</p>
</blockquote>
<ul>
<li>成员键都是<code>弱引用</code>，垃圾回收机制不考虑<code>WeakMap结构</code>对此成员键的引用</li>
<li>成员键不适合引用，它会随时消失，因此ES6规定<code>WeakMap结构不可遍历</code></li>
<li>其他对象不再引用成员键时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于<code>WeakMap结构</code>中</li>
<li>一旦不再需要，成员会自动消失，不用手动删除引用</li>
<li>弱引用的<code>只是键而不是值</code>，值依然是正常引用</li>
<li>即使在外部消除了成员键的引用，内部的成员值依然存在</li>
</ul>
<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><ul>
<li><p>定义：修改某些操作的默认行为</p>
</li>
<li><p>声明：<code>const proxy = new Proxy(target, handler)</code></p>
</li>
<li><p>入参</p>
</li>
<li><ul>
<li><strong>target</strong>：拦截的目标对象</li>
<li><strong>handler</strong>：定制拦截行为</li>
</ul>
</li>
<li><p>方法</p>
</li>
<li><ul>
<li><strong>Proxy.revocable()</strong>：返回可取消的Proxy实例(返回<code>{ proxy, revoke }</code>，通过revoke()取消代理)</li>
</ul>
</li>
<li><p>拦截方式</p>
</li>
<li><ul>
<li><strong>get()</strong>：拦截对象属性读取</li>
<li><strong>set()</strong>：拦截对象属性设置，返回布尔值</li>
<li><strong>has()</strong>：拦截对象属性检查<code>k in obj</code>，返回布尔值</li>
<li><strong>deleteProperty()</strong>：拦截对象属性删除<code>delete obj[k]</code>，返回布尔值</li>
<li><strong>defineProperty()</strong>：拦截对象属性定义<code>Object.defineProperty()</code>、<code>Object.defineProperties()</code>，返回布尔值</li>
<li><strong>ownKeys()</strong>：拦截对象属性遍历<code>for-in</code>、<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>Object.getOwnPropertySymbols()</code>，返回数组</li>
<li><strong>getOwnPropertyDescriptor()</strong>：拦截对象属性描述读取<code>Object.getOwnPropertyDescriptor()</code>，返回对象</li>
<li><strong>getPrototypeOf()</strong>：拦截对象原型读取<code>instanceof</code>、<code>Object.getPrototypeOf()</code>、<code>Object.prototype.__proto__</code>、<code>Object.prototype.isPrototypeOf()</code>、<code>Reflect.getPrototypeOf()</code>，返回对象</li>
<li><strong>setPrototypeOf()</strong>：拦截对象原型设置<code>Object.setPrototypeOf()</code>，返回布尔值</li>
<li><strong>isExtensible()</strong>：拦截对象是否可扩展读取<code>Object.isExtensible()</code>，返回布尔值</li>
<li><strong>preventExtensions()</strong>：拦截对象不可扩展设置<code>Object.preventExtensions()</code>，返回布尔值</li>
<li><strong>apply()</strong>：拦截Proxy实例作为函数调用<code>proxy()</code>、<code>proxy.apply()</code>、<code>proxy.call()</code></li>
<li><strong>construct()</strong>：拦截Proxy实例作为构造函数调用<code>new proxy()</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>应用场景</p>
</blockquote>
<ul>
<li><code>Proxy.revocable()</code>：不允许直接访问对象，必须通过代理访问，一旦访问结束就收回代理权不允许再次访问</li>
<li><code>get()</code>：读取未知属性报错、读取数组负数索引的值、封装链式操作、生成DOM嵌套节点</li>
<li><code>set()</code>：数据绑定(Vue数据绑定实现原理)、确保属性值设置符合要求、防止内部属性被外部读写</li>
<li><code>has()</code>：隐藏内部属性不被发现、排除不符合属性条件的对象</li>
<li><code>deleteProperty()</code>：保护内部属性不被删除</li>
<li><code>defineProperty()</code>：阻止属性被外部定义</li>
<li><code>ownKeys()</code>：保护内部属性不被遍历</li>
</ul>
<blockquote>
<p>重点难点</p>
</blockquote>
<ul>
<li>要使<code>Proxy</code>起作用，必须针对<code>实例</code>进行操作，而不是针对<code>目标对象</code>进行操作</li>
<li>没有设置任何拦截时，等同于<code>直接通向原对象</code></li>
<li>属性被定义为<code>不可读写/扩展/配置/枚举</code>时，使用拦截方法会报错</li>
<li>代理下的目标对象，内部<code>this</code>指向<code>Proxy代理</code></li>
</ul>
<h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><ul>
<li><p>定义：保持<code>Object方法</code>的默认行为</p>
</li>
<li><p>方法</p>
</li>
<li><ul>
<li><strong>get()</strong>：返回对象属性</li>
<li><strong>set()</strong>：设置对象属性，返回布尔值</li>
<li><strong>has()</strong>：检查对象属性，返回布尔值</li>
<li><strong>deleteProperty()</strong>：删除对象属性，返回布尔值</li>
<li><strong>defineProperty()</strong>：定义对象属性，返回布尔值</li>
<li><strong>ownKeys()</strong>：遍历对象属性，返回数组(<code>Object.getOwnPropertyNames()</code>+<code>Object.getOwnPropertySymbols()</code>)</li>
<li><strong>getOwnPropertyDescriptor()</strong>：返回对象属性描述，返回对象</li>
<li><strong>getPrototypeOf()</strong>：返回对象原型，返回对象</li>
<li><strong>setPrototypeOf()</strong>：设置对象原型，返回布尔值</li>
<li><strong>isExtensible()</strong>：返回对象是否可扩展，返回布尔值</li>
<li><strong>preventExtensions()</strong>：设置对象不可扩展，返回布尔值</li>
<li><strong>apply()</strong>：绑定this后执行指定函数</li>
<li><strong>construct()</strong>：调用构造函数创建实例</li>
</ul>
</li>
</ul>
<blockquote>
<p>设计目的</p>
</blockquote>
<ul>
<li>将<code>Object</code>属于<code>语言内部的方法</code>放到<code>Reflect</code>上</li>
<li>将某些Object方法报错情况改成返回<code>false</code></li>
<li>让<code>Object操作</code>变成<code>函数行为</code></li>
<li><code>Proxy</code>与<code>Reflect</code>相辅相成</li>
</ul>
<blockquote>
<p>废弃方法</p>
</blockquote>
<ul>
<li><code>Object.defineProperty()</code> =&gt; <code>Reflect.defineProperty()</code></li>
<li><code>Object.getOwnPropertyDescriptor()</code> =&gt; <code>Reflect.getOwnPropertyDescriptor()</code></li>
</ul>
<blockquote>
<p>重点难点</p>
</blockquote>
<ul>
<li><code>Proxy方法</code>和<code>Reflect方法</code>一一对应</li>
<li><code>Proxy</code>和<code>Reflect</code>联合使用，前者负责<code>拦截赋值操作</code>，后者负责<code>完成赋值操作</code></li>
</ul>
<blockquote>
<p>数据绑定：观察者模式</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observerQueue = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">const</span> observe = <span class="function"><span class="params">fn</span> =&gt;</span> observerQueue.add(fn);</span><br><span class="line"><span class="keyword">const</span> observable = <span class="function"><span class="params">obj</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="keyword">set</span>(tgt, key, val, receiver) &#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.set(tgt, key, val, receiver);</span><br><span class="line">        observerQueue.forEach(<span class="function"><span class="params">v</span> =&gt;</span> v());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = observable(&#123; <span class="attr">age</span>: <span class="number">25</span>, <span class="attr">name</span>: <span class="string">"Yajun"</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> print = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;person.name&#125;</span> is <span class="subst">$&#123;person.age&#125;</span> years old`</span>);</span><br><span class="line">observe(print);</span><br><span class="line">person.name = <span class="string">"Joway"</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><ul>
<li><p>定义：对一类具有共同特征的事物的抽象(构造函数语法糖)</p>
</li>
<li><p>原理：类本身指向构造函数，所有方法定义在<code>prototype</code>上，可看作构造函数的另一种写法(<code>Class === Class.prototype.constructor</code>)</p>
</li>
<li><p>方法和关键字</p>
</li>
<li><ul>
<li><strong>constructor()</strong>：构造函数，<code>new命令</code>生成实例时自动调用</li>
<li><strong>extends</strong>：继承父类</li>
<li><strong>super</strong>：新建父类的<code>this</code></li>
<li><strong>static</strong>：定义静态属性方法</li>
<li><strong>get</strong>：取值函数，拦截属性的取值行为</li>
<li><strong>set</strong>：存值函数，拦截属性的存值行为</li>
</ul>
</li>
<li><p>属性</p>
</li>
<li><ul>
<li><strong><strong>proto</strong></strong>：<code>构造函数的继承</code>(总是指向<code>父类</code>)</li>
<li><strong><strong>proto</strong>.<strong>proto</strong></strong>：子类的原型的原型，即父类的原型(总是指向父类的<code>__proto__</code>)</li>
<li><strong>prototype.<strong>proto</strong></strong>：<code>属性方法的继承</code>(总是指向父类的<code>prototype</code>)</li>
</ul>
</li>
<li><p>静态属性：定义类完成后赋值属性，该属性<code>不会被实例继承</code>，只能通过类来调用</p>
</li>
<li><p>静态方法：使用<code>static</code>定义方法，该方法<code>不会被实例继承</code>，只能通过类来调用(方法中的<code>this</code>指向类，而不是实例)</p>
</li>
<li><p>继承</p>
</li>
<li><ul>
<li>父类静态属性方法可被子类继承</li>
<li>子类继承父类后，可从<code>super</code>上调用父类静态属性方法</li>
<li>作为函数调用：只能在构造函数中调用<code>super()</code>，内部<code>this</code>指向继承的<code>当前子类</code>(<code>super()</code>调用后才可在构造函数中使用<code>this</code>)</li>
<li>作为对象调用：在<code>普通方法</code>中指向<code>父类的原型对象</code>，在<code>静态方法</code>中指向<code>父类</code></li>
<li>ES5实质：先创造子类实例的<code>this</code>，再将父类的属性方法添加到<code>this</code>上(<code>Parent.apply(this)</code>)</li>
<li>ES6实质：先将父类实例的属性方法加到<code>this</code>上(调用<code>super()</code>)，再用子类构造函数修改<code>this</code></li>
<li>实质</li>
<li>super</li>
<li>显示定义：使用<code>constructor() { super(); }</code>定义继承父类，没有书写则<code>显示定义</code></li>
<li>子类继承父类：子类使用父类的属性方法时，必须在构造函数中调用<code>super()</code>，否则得不到父类的<code>this</code></li>
</ul>
</li>
<li><p>实例：类相当于<code>实例的原型</code>，所有在类中定义的属性方法都会被实例继承</p>
</li>
<li><ul>
<li>显式指定属性方法：使用<code>this</code>指定到自身上(使用<code>Class.hasOwnProperty()</code>可检测到)</li>
<li>隐式指定属性方法：直接声明定义在对象原型上(使用<code>Class.__proto__.hasOwnProperty()</code>可检测到)</li>
</ul>
</li>
<li><p>表达式</p>
</li>
<li><ul>
<li>类表达式：<code>const Class = class {}</code></li>
<li>name属性：返回紧跟<code>class</code>后的类名</li>
<li>属性表达式：<code>[prop]</code></li>
<li>Generator方法：<code>* mothod() {}</code></li>
<li>Async方法：<code>async mothod() {}</code></li>
</ul>
</li>
<li><p>this指向：解构实例属性或方法时会报错</p>
</li>
<li><ul>
<li>绑定this：<code>this.mothod = this.mothod.bind(this)</code></li>
<li>箭头函数：<code>this.mothod = () =&gt; this.mothod()</code></li>
</ul>
</li>
<li><p>属性定义位置</p>
</li>
<li><ul>
<li>定义在构造函数中并使用<code>this</code>指向</li>
<li>定义在<code>类最顶层</code></li>
</ul>
</li>
<li><p><strong>new.target</strong>：确定构造函数是如何调用</p>
</li>
</ul>
<blockquote>
<p>原生构造函数</p>
</blockquote>
<ul>
<li><strong>String()</strong></li>
<li><strong>Number()</strong></li>
<li><strong>Boolean()</strong></li>
<li><strong>Array()</strong></li>
<li><strong>Object()</strong></li>
<li><strong>Function()</strong></li>
<li><strong>Date()</strong></li>
<li><strong>RegExp()</strong></li>
<li><strong>Error()</strong></li>
</ul>
<blockquote>
<p>重点难点</p>
</blockquote>
<ul>
<li>在实例上调用方法，实质是调用原型上的方法</li>
<li><code>Object.assign()</code>可方便地一次向类添加多个方法(<code>Object.assign(Class.prototype, { ... })</code>)</li>
<li>类内部所有定义的方法是不可枚举的(<code>non-enumerable</code>)</li>
<li>构造函数默认返回实例对象(<code>this</code>)，可指定返回另一个对象</li>
<li>取值函数和存值函数设置在属性的<code>Descriptor对象</code>上</li>
<li>类不存在变量提升</li>
<li>利用<code>new.target === Class</code>写出不能独立使用必须继承后才能使用的类</li>
<li>子类继承父类后，<code>this</code>指向子类实例，通过<code>super</code>对某个属性赋值，赋值的属性会变成子类实例的属性</li>
<li>使用<code>super</code>时，必须显式指定是作为函数还是作为对象使用</li>
<li><code>extends</code>不仅可继承类还可继承原生的构造函数</li>
</ul>
<blockquote>
<p>私有属性方法</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="built_in">Symbol</span>(<span class="string">"name"</span>);</span><br><span class="line"><span class="keyword">const</span> print = <span class="built_in">Symbol</span>(<span class="string">"print"</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(age) &#123;</span><br><span class="line">        <span class="keyword">this</span>[name] = <span class="string">"Bruce"</span>;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    [print]() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>[name]&#125;</span> is <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span> years old`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>继承混合类</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CopyProperties</span>(<span class="params">target, source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="built_in">Reflect</span>.ownKeys(source)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key !== <span class="string">"constructor"</span> &amp;&amp; key !== <span class="string">"prototype"</span> &amp;&amp; key !== <span class="string">"name"</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(source, key);</span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(target, key, desc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MixClass</span>(<span class="params">...mixins</span>) </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Mix</span> </span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>() &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> mixin <span class="keyword">of</span> mixins) &#123;</span><br><span class="line">                CopyProperties(<span class="keyword">this</span>, <span class="keyword">new</span> mixin());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> mixin <span class="keyword">of</span> mixins) &#123;</span><br><span class="line">        CopyProperties(Mix, mixin);</span><br><span class="line">        CopyProperties(Mix.prototype, mixin.prototype);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Mix;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">MixClass</span>(<span class="title">Person</span>, <span class="title">Kid</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><ul>
<li><p>命令</p>
</li>
<li><ul>
<li><strong>默认导入导出</strong>：<code>export { default } from &quot;person&quot;</code></li>
<li><strong>整体导入导出</strong>：<code>export * from &quot;person&quot;</code></li>
<li><strong>按需导入导出</strong>：<code>export { age, name, sex } from &quot;person&quot;</code></li>
<li><strong>改名导入导出</strong>：<code>export { name as newName } from &quot;person&quot;</code></li>
<li><strong>具名改默认导入导出</strong>：<code>export { name as default } from &quot;person&quot;</code></li>
<li><strong>默认改具名导入导出</strong>：<code>export { default as name } from &quot;person&quot;</code></li>
<li><strong>默认导入</strong>：<code>import Person from &quot;person&quot;</code></li>
<li><strong>整体导入</strong>：<code>import * as Person from &quot;person&quot;</code></li>
<li><strong>按需导入</strong>：<code>import { age, name, sex } from &quot;person&quot;</code></li>
<li><strong>改名导入</strong>：<code>import { name as newName } from &quot;person&quot;</code></li>
<li><strong>自执导入</strong>：<code>import &quot;person&quot;</code></li>
<li><strong>复合导入</strong>：<code>import Person, { name } from &quot;person&quot;</code></li>
<li><strong>默认导出</strong>：<code>export default Person</code>(导入时可指定模块任意名称，无需知晓内部真实名称)</li>
<li><strong>单独导出</strong>：<code>export const name = &quot;Bruce&quot;</code></li>
<li><strong>按需导出</strong>：<code>export { age, name, sex }</code>(推荐)</li>
<li><strong>改名导出</strong>：<code>export { name as newName }</code></li>
<li><strong>export</strong>：规定模块对外接口</li>
<li><strong>import</strong>：导入模块内部功能</li>
<li><strong>复合模式</strong>：<code>export命令</code>和<code>import命令</code>结合在一起写成一行，变量实质没有被导入当前模块，相当于对外转发接口，导致当前模块无法直接使用其导入变量</li>
</ul>
</li>
<li><p>继承：<code>默认导出</code>和<code>改名导出</code>结合使用可使模块具备继承性</p>
</li>
<li><p>设计思想：尽量地静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量</p>
</li>
<li><p>严格模式：ES6模块自动采用严格模式(不管模块头部是否添加<code>use strict</code>)</p>
</li>
</ul>
<blockquote>
<p>模块方案</p>
</blockquote>
<ul>
<li><strong>CommonJS</strong>：用于服务器(动态化依赖)</li>
<li><strong>AMD</strong>：用于浏览器(动态化依赖)</li>
<li><strong>CMD</strong>：用于浏览器(动态化依赖)</li>
<li><strong>UMD</strong>：用于浏览器和服务器(动态化依赖)</li>
<li><strong>ESM</strong>：用于浏览器和服务器(静态化依赖)</li>
</ul>
<blockquote>
<p>加载方式</p>
</blockquote>
<ul>
<li><p><strong>运行时加载</strong></p>
</li>
<li><ul>
<li>定义：整体加载模块生成一个对象，再从对象上获取需要的属性和方法进行加载(全部加载)</li>
<li>影响：只有运行时才能得到这个对象，导致无法在编译时做静态优化</li>
</ul>
</li>
<li><p><strong>编译时加载</strong></p>
</li>
<li><ul>
<li>定义：直接从模块中获取需要的属性和方法进行加载(按需加载)</li>
<li>影响：在编译时就完成模块加载，效率比其他方案高，但无法引用模块本身(<strong>本身不是对象</strong>)，可拓展JS高级语法(<strong>宏和类型校验</strong>)</li>
</ul>
</li>
</ul>
<blockquote>
<p>加载实现</p>
</blockquote>
<ul>
<li><p><strong>传统加载</strong>：通过``进行同步或异步加载脚本</p>
</li>
<li><ul>
<li>同步加载：``</li>
<li>Defer异步加载：``(顺序加载，渲染完再执行)</li>
<li>Async异步加载：``(乱序加载，下载完就执行)</li>
</ul>
</li>
<li><p><strong>模块加载</strong>：``(默认是Defer异步加载)</p>
</li>
</ul>
<blockquote>
<p>CommonJS和ESM的区别</p>
</blockquote>
<ul>
<li><p><code>CommonJS</code>输出<code>值的拷贝</code>，<code>ESM</code>输出<code>值的引用</code></p>
</li>
<li><ul>
<li><code>CommonJS</code>一旦输出一个值，模块内部的变化就影响不到这个值</li>
<li><code>ESM</code>是动态引用且不会缓存值，模块里的变量绑定其所在的模块，等到脚本真正执行时，再根据这个只读引用到被加载的那个模块里去取值</li>
</ul>
</li>
<li><p><code>CommonJS</code>是运行时加载，<code>ESM</code>是编译时加载</p>
</li>
<li><ul>
<li><code>CommonJS</code>加载模块是对象(即<code>module.exports</code>)，该对象只有在脚本运行完才会生成</li>
<li><code>ESM</code>加载模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成</li>
</ul>
</li>
</ul>
<blockquote>
<p>Node加载</p>
</blockquote>
<ul>
<li><p>背景：<code>CommonJS</code>和<code>ESM</code>互不兼容，目前解决方案是将两者分开，采用各自的加载方案</p>
</li>
<li><p>区分：要求<code>ESM</code>采用<code>.mjs</code>后缀文件名</p>
</li>
<li><ul>
<li><code>require()</code>不能加载<code>.mjs文件</code>，只有<code>import命令</code>才可加载<code>.mjs文件</code></li>
<li><code>.mjs文件</code>里不能使用<code>require()</code>，必须使用<code>import命令</code>加载文件</li>
</ul>
</li>
<li><p>驱动：<code>node --experimental-modules file.mjs</code></p>
</li>
<li><p>限制：Node的<code>import命令</code>目前只支持加载本地模块(<code>file:协议</code>)，不支持加载远程模块</p>
</li>
<li><p>加载优先级</p>
</li>
<li><ul>
<li>脚本文件省略后缀名：依次尝试加载四个后缀名文件(<code>.mjs</code>、<code>.js</code>、<code>.json</code>、<code>node</code>)</li>
<li>以上不存在：尝试加载<code>package.json</code>的<code>main字段</code>指定的脚本</li>
<li>以上不存在：依次尝试加载名称为<code>index</code>四个后缀名文件(<code>.mjs</code>、<code>.js</code>、<code>.json</code>、<code>node</code>)</li>
<li>以上不存在：报错</li>
</ul>
</li>
<li><p>不存在的内部变量：<code>arguments</code>、<code>exports</code>、<code>module</code>、<code>require</code>、<code>this</code>、<code>__dirname</code>、<code>__filename</code></p>
</li>
<li><p>CommonJS加载ESM</p>
</li>
<li><ul>
<li>不能使用<code>require()</code>，只能使用<code>import()</code></li>
</ul>
</li>
<li><p>ESM加载CommonJS</p>
</li>
<li><ul>
<li>自动将<code>module.exports</code>转化成<code>export default</code></li>
<li><code>CommonJS</code>输出缓存机制在<code>ESM</code>加载方式下依然有效</li>
<li>采用<code>import命令</code>加载<code>CommonJS模块</code>时，不允许采用<code>按需导入</code>，应使用<code>默认导入</code>或<code>整体导入</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>循环加载</p>
</blockquote>
<ul>
<li><p>定义：<code>脚本A</code>的执行依赖<code>脚本B</code>，而<code>脚本A</code>的执行又依赖<code>脚本B</code></p>
</li>
<li><p>加载原理</p>
</li>
<li><ul>
<li>CommonJS：<code>require()</code>首次加载脚本就会执行整个脚本，在内存里生成一个对象缓存下来，二次加载脚本时直接从缓存中获取</li>
<li>ESM：<code>import命令</code>加载变量不会被缓存，而是成为一个指向被加载模块的引用</li>
</ul>
</li>
<li><p>循环加载</p>
</li>
<li><ul>
<li>CommonJS：只输出已经执行的部分，还未执行的部分不会输出</li>
<li>ESM：需开发者自己保证真正取值时能够取到值(可把变量写成函数形式，函数具有提升作用)</li>
</ul>
</li>
</ul>
<blockquote>
<p>重点难点</p>
</blockquote>
<ul>
<li>ES6模块中，顶层<code>this</code>指向<code>undefined</code>，不应该在顶层代码使用<code>this</code></li>
<li>一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取</li>
<li><code>export命令</code>输出的接口与其对应的值是<code>动态绑定关系</code>，即通过该接口可获取模块内部实时的值</li>
<li><code>import命令</code>大括号里的变量名必须与被导入模块对外接口的名称相同</li>
<li><code>import命令</code>输入的变量只读(本质是输入接口)，不允许在加载模块的脚本里改写接口</li>
<li><code>import命令</code>命令具有提升效果，会提升到整个模块的头部，首先执行</li>
<li>重复执行同一句<code>import语句</code>，只会执行一次</li>
<li><code>export default</code>命令只能使用一次</li>
<li><code>export default命令</code>导出的整体模块，在执行<code>import命令</code>时其后不能跟<code>大括号</code></li>
<li><code>export default命令</code>本质是输出一个名为<code>default</code>的变量，后面不能跟<code>变量声明语句</code></li>
<li><code>export default命令</code>本质是将后面的值赋给名为<code>default</code>的变量，可直接将值写在其后</li>
<li><code>export default命令</code>和<code>export {}命令</code>可同时存在，对应<code>复合导入</code></li>
<li><code>export命令</code>和<code>import命令</code>可出现在模块任何位置，只要处于模块顶层即可，不能处于块级作用域</li>
<li><code>import()</code>加载模块成功后，此模块会作为一个对象，当作<code>then()</code>的参数，可使用<code>对象解构赋值</code>来获取输出接口</li>
<li>同时动态加载多个模块时，可使用<code>Promise.all()</code>和<code>import()</code>相结合来实现</li>
<li><code>import()</code>和结合<code>async/await</code>来书写同步操作的代码</li>
</ul>
<blockquote>
<p>单例模式：跨模块常量</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常量跨文件共享</span></span><br><span class="line"><span class="comment">// person.js</span></span><br><span class="line"><span class="keyword">const</span> NAME = <span class="string">"Bruce"</span>;</span><br><span class="line"><span class="keyword">const</span> AGE = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">const</span> SEX = <span class="string">"male"</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; AGE, NAME, SEX &#125;;</span><br><span class="line"><span class="comment">// file1.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; AGE &#125; <span class="keyword">from</span> <span class="string">"person"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(AGE);</span><br><span class="line"><span class="comment">// file2.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; AGE, NAME, SEX &#125; <span class="keyword">from</span> <span class="string">"person"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(AGE, NAME, SEX);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>默认导入互换整体导入</p>
</blockquote>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Person <span class="keyword">from</span> <span class="string">"person"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(Person.AGE);</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Person <span class="keyword">from</span> <span class="string">"person"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(Person.<span class="keyword">default</span>.AGE);</span><br></pre></td></tr></table></figure>

<h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><ul>
<li><p>定义：为各种不同的数据结构提供统一的访问机制</p>
</li>
<li><p>原理：创建一个指针指向首个成员，按照次序使用<code>next()</code>指向下一个成员，直接到结束位置(数据结构只要部署<code>Iterator接口</code>就可完成遍历操作)</p>
</li>
<li><p>作用</p>
</li>
<li><ul>
<li>为各种数据结构提供一个统一的简便的访问接口</li>
<li>使得数据结构成员能够按某种次序排列</li>
<li>ES6创造了新的遍历命令<code>for-of</code>，<code>Iterator接口</code>主要供<code>for-of</code>消费</li>
</ul>
</li>
<li><p>形式：<code>for-of</code>(自动去寻找Iterator接口)</p>
</li>
<li><p>数据结构</p>
</li>
<li><ul>
<li>集合：<code>Array</code>、<code>Object</code>、<code>Set</code>、<code>Map</code></li>
<li>原生具备接口的数据结构：<code>String</code>、<code>Array</code>、<code>Set</code>、<code>Map</code>、<code>TypedArray</code>、<code>Arguments</code>、<code>NodeList</code></li>
</ul>
</li>
<li><p>部署：默认部署在<code>Symbol.iterator</code>(具备此属性被认为<code>可遍历的iterable</code>)</p>
</li>
<li><p>遍历器对象</p>
</li>
<li><ul>
<li><strong>next()</strong>：下一步操作，返回<code>{ done, value }</code>(必须部署)</li>
<li><strong>return()</strong>：<code>for-of</code>提前退出调用，返回<code>{ done: true }</code></li>
<li><strong>throw()</strong>：不使用，配合<code>Generator函数</code>使用</li>
</ul>
</li>
</ul>
<blockquote>
<p>ForOf循环</p>
</blockquote>
<ul>
<li><p>定义：调用<code>Iterator接口</code>产生遍历器对象(<code>for-of</code>内部调用数据结构的<code>Symbol.iterator()</code>)</p>
</li>
<li><p>遍历字符串：<code>for-in</code>获取<code>索引</code>，<code>for-of</code>获取<code>值</code>(可识别32位UTF-16字符)</p>
</li>
<li><p>遍历数组：<code>for-in</code>获取<code>索引</code>，<code>for-of</code>获取<code>值</code></p>
</li>
<li><p>遍历对象：<code>for-in</code>获取<code>键</code>，<code>for-of</code>需自行部署</p>
</li>
<li><p>遍历Set：<code>for-of</code>获取<code>值</code> =&gt; <code>for (const v of set)</code></p>
</li>
<li><p>遍历Map：<code>for-of</code>获取<code>键值对</code> =&gt;  <code>for (const [k, v] of map)</code></p>
</li>
<li><p>遍历类数组：<code>包含length的对象</code>、<code>Arguments对象</code>、<code>NodeList对象</code>(无<code>Iterator接口的类数组</code>可用<code>Array.from()</code>转换)</p>
</li>
<li><p>计算生成数据结构：<code>Array</code>、<code>Set</code>、<code>Map</code></p>
</li>
<li><ul>
<li><strong>keys()</strong>：返回遍历器对象，遍历所有的键</li>
<li><strong>values()</strong>：返回遍历器对象，遍历所有的值</li>
<li><strong>entries()</strong>：返回遍历器对象，遍历所有的键值对</li>
</ul>
</li>
<li><p>与<code>for-in</code>区别</p>
</li>
<li><ul>
<li>有着同<code>for-in</code>一样的简洁语法，但没有<code>for-in</code>那些缺点、</li>
<li>不同于<code>forEach()</code>，它可与<code>break</code>、<code>continue</code>和<code>return</code>配合使用</li>
<li>提供遍历所有数据结构的统一操作接口</li>
</ul>
</li>
</ul>
<blockquote>
<p>应用场景</p>
</blockquote>
<ul>
<li>改写具有<code>Iterator接口</code>的数据结构的<code>Symbol.iterator</code></li>
<li>解构赋值：对Set进行结构</li>
<li>扩展运算符：将部署<code>Iterator接口</code>的数据结构转为数组</li>
<li>yield<em>：`yield</em>`后跟一个可遍历的数据结构，会调用其遍历器接口</li>
<li>接受数组作为参数的函数：<code>for-of</code>、<code>Array.from()</code>、<code>new Set()</code>、<code>new WeakSet()</code>、<code>new Map()</code>、<code>new WeakMap()</code>、<code>Promise.all()</code>、<code>Promise.race()</code></li>
</ul>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><ul>
<li><p>定义：包含异步操作结果的对象</p>
</li>
<li><p>状态</p>
</li>
<li><ul>
<li><strong>进行中</strong>：<code>pending</code></li>
<li><strong>已成功</strong>：<code>resolved</code></li>
<li><strong>已失败</strong>：<code>rejected</code></li>
</ul>
</li>
<li><p>特点</p>
</li>
<li><ul>
<li>对象的状态不受外界影响</li>
<li>一旦状态改变就不会再变，任何时候都可得到这个结果</li>
</ul>
</li>
<li><p>声明：<code>new Promise((resolve, reject) =&gt; {})</code></p>
</li>
<li><p>出参</p>
</li>
<li><ul>
<li><strong>resolve</strong>：将状态从<code>未完成</code>变为<code>成功</code>，在异步操作成功时调用，并将异步操作的结果作为参数传递出去</li>
<li><strong>reject</strong>：将状态从<code>未完成</code>变为<code>失败</code>，在异步操作失败时调用，并将异步操作的错误作为参数传递出去</li>
</ul>
</li>
<li><p>方法</p>
</li>
<li><ul>
<li><strong>Promise实例</strong>：原封不动地返回入参</li>
<li><strong>Thenable对象</strong>：将此对象转为Promise对象并返回(Thenable为包含<code>then()</code>的对象，执行<code>then()</code>相当于执行此对象的<code>then()</code>)</li>
<li><strong>不具有then()的对象</strong>：将此对象转为Promise对象并返回，状态为<code>resolved</code></li>
<li><strong>不带参数</strong>：返回Promise对象，状态为<code>resolved</code></li>
<li>入参：具有<code>Iterator接口</code>的数据结构</li>
<li>成功：只有全部实例状态变成<code>resolved</code>，最终状态才会变成<code>resolved</code></li>
<li>失败：其中一个实例状态变成<code>rejected</code>，最终状态就会变成<code>rejected</code></li>
<li><strong>第一参数</strong>：状态变为<code>resolved</code>时调用</li>
<li><strong>第二参数</strong>：状态变为<code>rejected</code>时调用(可选)</li>
<li><strong>then()</strong>：分别指定<code>resolved状态</code>和<code>rejected状态</code>的回调函数</li>
<li><strong>catch()</strong>：指定发生错误时的回调函数</li>
<li><strong>Promise.all()</strong>：将多个实例包装成一个新实例，返回全部实例状态变更后的结果数组(齐变更再返回)</li>
<li><strong>Promise.race()</strong>：将多个实例包装成一个新实例，返回全部实例状态优先变更后的结果(先变更先返回)</li>
<li><strong>Promise.resolve()</strong>：将对象转为Promise对象(等价于<code>new Promise(resolve =&gt; resolve())</code>)</li>
<li><strong>Promise.reject()</strong>：将对象转为状态为<code>rejected</code>的Promise对象(等价于<code>new Promise((resolve, reject) =&gt; reject())</code>)</li>
</ul>
</li>
</ul>
<blockquote>
<p>应用场景</p>
</blockquote>
<ul>
<li>加载图片</li>
<li>AJAX转Promise对象</li>
</ul>
<blockquote>
<p>重点难点</p>
</blockquote>
<ul>
<li>只有异步操作的结果可决定当前状态是哪一种，其他操作都无法改变这个状态</li>
<li>状态改变只有两种可能：从<code>pending</code>变为<code>resolved</code>、从<code>pending</code>变为<code>rejected</code></li>
<li>一旦新建<code>Promise对象</code>就会立即执行，无法中途取消</li>
<li>不设置回调函数，内部抛错不会反应到外部</li>
<li>当处于<code>pending</code>时，无法得知目前进展到哪一个阶段</li>
<li>实例状态变为<code>resolved</code>或<code>rejected</code>时，会触发<code>then()</code>绑定的回调函数</li>
<li><code>resolve()</code>和<code>reject()</code>的执行总是晚于本轮循环的同步任务</li>
<li><code>then()</code>返回新实例，其后可再调用另一个<code>then()</code></li>
<li><code>then()</code>运行中抛出错误会被<code>catch()</code>捕获</li>
<li><code>reject()</code>的作用等同于抛出错误</li>
<li>实例状态已变成<code>resolved</code>时，再抛出错误是无效的，不会被捕获，等于没有抛出</li>
<li>实例状态的错误具有<code>冒泡</code>性质，会一直向后传递直到被捕获为止，错误总是会被下一个<code>catch()</code>捕获</li>
<li>不要在<code>then()</code>里定义<code>rejected</code>状态的回调函数(不使用其第二参数)</li>
<li>建议使用<code>catch()</code>捕获错误，不要使用<code>then()</code>第二个参数捕获</li>
<li>没有使用<code>catch()</code>捕获错误，实例抛错不会传递到外层代码，即<code>不会有任何反应</code></li>
<li>作为参数的实例定义了<code>catch()</code>，一旦被<code>rejected</code>并不会触发<code>Promise.all()</code>的<code>catch()</code></li>
<li><code>Promise.reject()</code>的参数会原封不动地作为<code>rejected</code>的理由，变成后续方法的参数</li>
</ul>
<h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><ul>
<li><p>定义：封装多个内部状态的异步编程解决方案</p>
</li>
<li><p>形式：调用<code>Generator函数</code>(该函数不执行)返回指向内部状态的指针对象(不是运行结果)</p>
</li>
<li><p>声明：<code>function* Func() {}</code></p>
</li>
<li><p>方法</p>
</li>
<li><ul>
<li><strong>next()</strong>：使指针移向下一个状态，返回<code>{ done, value }</code>(入参会被当作上一个<code>yield命令表达式</code>的返回值)</li>
<li><strong>return()</strong>：返回指定值且终结遍历<code>Generator函数</code>，返回<code>{ done: true, value: 入参 }</code></li>
<li><strong>throw()</strong>：在<code>Generator函数</code>体外抛出错误，在<code>Generator函数</code>体内捕获错误，返回自定义的<code>new Errow()</code></li>
</ul>
</li>
<li><p>yield命令：声明内部状态的值(<code>return</code>声明结束返回的值)</p>
</li>
<li><ul>
<li>遇到<code>yield命令</code>就暂停执行后面的操作，并将其后表达式的值作为返回对象的<code>value</code></li>
<li>下次调用<code>next()</code>时，再继续往下执行直到遇到下一个<code>yield命令</code></li>
<li>没有再遇到<code>yield命令</code>就一直运行到<code>Generator函数</code>结束，直到遇到<code>return语句</code>为止并将其后表达式的值作为返回对象的<code>value</code></li>
<li><code>Generator函数</code>没有<code>return语句</code>则返回对象的<code>value</code>为<code>undefined</code></li>
</ul>
</li>
<li><p>yield*命令：在一个<code>Generator函数</code>里执行另一个<code>Generator函数</code>(后随具有<code>Iterator接口</code>的数据结构)</p>
</li>
<li><p>遍历：通过<code>for-of</code>自动调用<code>next()</code></p>
</li>
<li><p>作为对象属性</p>
</li>
<li><ul>
<li>全写：<code>const obj = { method: function*() {} }</code></li>
<li>简写：<code>const obj = { * method() {} }</code></li>
</ul>
</li>
<li><p>上下文：执行产生的<code>上下文环境</code>一旦遇到<code>yield命令</code>就会暂时退出堆栈(但并不消失)，所有变量和对象会冻结在<code>当前状态</code>，等到对它执行<code>next()</code>时，这个<code>上下文环境</code>又会重新加入调用栈，冻结的变量和对象恢复执行</p>
</li>
</ul>
<blockquote>
<p>方法异同</p>
</blockquote>
<ul>
<li><p>相同点：<code>next()</code>、<code>throw()</code>、<code>return()</code>本质上是同一件事，作用都是让函数恢复执行且使用不同的语句替换<code>yield命令</code></p>
</li>
<li><p>不同点</p>
</li>
<li><ul>
<li><strong>next()</strong>：将<code>yield命令</code>替换成一个<code>值</code></li>
<li><strong>return()</strong>：将<code>yield命令</code>替换成一个<code>return语句</code></li>
<li><strong>throw()</strong>：将<code>yield命令</code>替换成一个<code>throw语句</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>应用场景</p>
</blockquote>
<ul>
<li>异步操作同步化表达</li>
<li>控制流管理</li>
<li>为对象部署Iterator接口：把<code>Generator函数</code>赋值给对象的<code>Symbol.iterator</code>，从而使该对象具有<code>Iterator接口</code></li>
<li>作为具有Iterator接口的数据结构</li>
</ul>
<blockquote>
<p>重点难点</p>
</blockquote>
<ul>
<li>每次调用<code>next()</code>，指针就从<code>函数头部</code>或<code>上次停下的位置</code>开始执行，直到遇到下一个<code>yield命令</code>或<code>return语句</code>为止</li>
<li>函数内部可不用<code>yield命令</code>，但会变成单纯的<code>暂缓执行函数</code>(还是需要<code>next()</code>触发)</li>
<li><code>yield命令</code>是暂停执行的标记，<code>next()</code>是恢复执行的操作</li>
<li><code>yield命令</code>用在另一个表达式中必须放在<code>圆括号</code>里</li>
<li><code>yield命令</code>用作函数参数或放在赋值表达式的右边，可不加<code>圆括号</code></li>
<li><code>yield命令</code>本身没有返回值，可认为是返回<code>undefined</code></li>
<li><code>yield命令表达式</code>为惰性求值，等<code>next()</code>执行到此才求值</li>
<li>函数调用后生成遍历器对象，此对象的<code>Symbol.iterator</code>是此对象本身</li>
<li>在函数运行的不同阶段，通过<code>next()</code>从外部向内部注入不同的值，从而调整函数行为</li>
<li>首个<code>next()</code>用来启动遍历器对象，后续才可传递参数</li>
<li>想首次调用<code>next()</code>时就能输入值，可在函数外面再包一层</li>
<li>一旦<code>next()</code>返回对象的<code>done</code>为<code>true</code>，<code>for-of</code>遍历会中止且不包含该返回对象</li>
<li>函数内部部署<code>try-finally</code>且正在执行<code>try</code>，那么<code>return()</code>会导致立刻进入<code>finally</code>，执行完<code>finally</code>以后整个函数才会结束</li>
<li>函数内部没有部署<code>try-catch</code>，<code>throw()</code>抛错将被外部<code>try-catch</code>捕获</li>
<li><code>throw()</code>抛错要被内部捕获，前提是必须<code>至少执行过一次next()</code></li>
<li><code>throw()</code>被捕获以后，会附带执行下一条<code>yield命令</code></li>
<li>函数还未开始执行，这时<code>throw()</code>抛错只可能抛出在函数外部</li>
</ul>
<blockquote>
<p>首次next()可传值</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Wrapper</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> generator = func(...args);</span><br><span class="line">        generator.next();</span><br><span class="line">        <span class="keyword">return</span> generator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> print = Wrapper(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`First Input: <span class="subst">$&#123;<span class="keyword">yield</span>&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"done"</span>;</span><br><span class="line">&#125;);</span><br><span class="line">print().next(<span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="ES2016"><a href="#ES2016" class="headerlink" title="ES2016"></a>ES2016</h2><h3 id="数值扩展-1"><a href="#数值扩展-1" class="headerlink" title="数值扩展"></a>数值扩展</h3><ul>
<li><input checked disabled type="checkbox"> <strong>指数运算符(\</strong>)**：数值求幂(相当于<code>Math.pow()</code>)</li>
</ul>
<h3 id="数组扩展-1"><a href="#数组扩展-1" class="headerlink" title="数组扩展"></a>数组扩展</h3><ul>
<li><input checked disabled type="checkbox"> <strong>includes()</strong>：是否存在指定成员</li>
</ul>
<h2 id="ES2017"><a href="#ES2017" class="headerlink" title="ES2017"></a>ES2017</h2><h3 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h3><ul>
<li><input checked disabled type="checkbox"> <strong>共享内存和原子操作</strong>：由全局对象<code>SharedArrayBuffer</code>和<code>Atomics</code>实现，将数据存储在一块共享内存空间中，这些数据可在<code>JS主线程</code>和<code>web-worker线程</code>之间共享</li>
</ul>
<h3 id="字符串扩展-1"><a href="#字符串扩展-1" class="headerlink" title="字符串扩展"></a>字符串扩展</h3><ul>
<li><input checked disabled type="checkbox"> <strong>padStart()</strong>：把指定字符串填充到字符串头部，返回新字符串</li>
<li><input checked disabled type="checkbox"> <strong>padEnd()</strong>：把指定字符串填充到字符串尾部，返回新字符串</li>
</ul>
<h3 id="对象扩展-1"><a href="#对象扩展-1" class="headerlink" title="对象扩展"></a>对象扩展</h3><ul>
<li><input checked disabled type="checkbox"> <strong>Object.getOwnPropertyDescriptors()</strong>：返回对象所有自身属性(非继承属性)的描述对象</li>
<li><input checked disabled type="checkbox"> <strong>Object.values()</strong>：返回以值组成的数组</li>
<li><input checked disabled type="checkbox"> <strong>Object.entries()</strong>：返回以键和值组成的数组</li>
</ul>
<h3 id="函数扩展-1"><a href="#函数扩展-1" class="headerlink" title="函数扩展"></a>函数扩展</h3><ul>
<li><input checked disabled type="checkbox"> <strong>函数参数尾逗号</strong>：允许函数最后一个参数有尾逗号</li>
</ul>
<h3 id="Async"><a href="#Async" class="headerlink" title="Async"></a>Async</h3><ul>
<li><p>定义：使异步函数以同步函数的形式书写(Generator函数语法糖)</p>
</li>
<li><p>原理：将<code>Generator函数</code>和自动执行器<code>spawn</code>包装在一个函数里</p>
</li>
<li><p>形式：将<code>Generator函数</code>的<code>*</code>替换成<code>async</code>，将<code>yield</code>替换成<code>await</code></p>
</li>
<li><p>声明</p>
</li>
<li><ul>
<li>具名函数：<code>async function Func() {}</code></li>
<li>函数表达式：<code>const func = async function() {}</code></li>
<li>箭头函数：<code>const func = async() =&gt; {}</code></li>
<li>对象方法：<code>const obj = { async func() {} }</code></li>
<li>类方法：<code>class Cla { async Func() {} }</code></li>
</ul>
</li>
<li><p>await命令：等待当前Promise对象状态变更完毕</p>
</li>
<li><ul>
<li>正常情况：后面是Promise对象则返回其结果，否则返回对应的值</li>
<li>后随<code>Thenable对象</code>：将其等同于Promise对象返回其结果</li>
</ul>
</li>
<li><p>错误处理：将<code>await命令Promise对象</code>放到<code>try-catch</code>中(可放多个)</p>
</li>
</ul>
<blockquote>
<p>Async对Generator改进</p>
</blockquote>
<ul>
<li>内置执行器</li>
<li>更好的语义</li>
<li>更广的适用性</li>
<li>返回值是Promise对象</li>
</ul>
<blockquote>
<p>应用场景</p>
</blockquote>
<ul>
<li>按顺序完成异步操作</li>
</ul>
<blockquote>
<p>重点难点</p>
</blockquote>
<ul>
<li><p><code>Async函数</code>返回<code>Promise对象</code>，可使用<code>then()</code>添加回调函数</p>
</li>
<li><p>内部<code>return返回值</code>会成为后续<code>then()</code>的出参</p>
</li>
<li><p>内部抛出错误会导致返回的Promise对象变为<code>rejected状态</code>，被<code>catch()</code>接收到</p>
</li>
<li><p>返回的Promise对象必须等到内部所有<code>await命令Promise对象</code>执行完才会发生状态改变，除非遇到<code>return语句</code>或<code>抛出错误</code></p>
</li>
<li><p>任何一个<code>await命令Promise对象</code>变为<code>rejected状态</code>，整个<code>Async函数</code>都会中断执行</p>
</li>
<li><p>希望即使前一个异步操作失败也不要中断后面的异步操作</p>
</li>
<li><ul>
<li>将<code>await命令Promise对象</code>放到<code>try-catch</code>中</li>
<li><code>await命令Promise对象</code>跟一个<code>catch()</code></li>
</ul>
</li>
<li><p><code>await命令Promise对象</code>可能变为<code>rejected状态</code>，最好把其放到<code>try-catch</code>中</p>
</li>
<li><p>多个<code>await命令Promise对象</code>若不存在继发关系，最好让它们同时触发</p>
</li>
<li><p><code>await命令</code>只能用在<code>Async函数</code>之中，否则会报错</p>
</li>
<li><p>数组使用<code>forEach()</code>执行<code>async/await</code>会失效，可使用<code>for-of</code>和<code>Promise.all()</code>代替</p>
</li>
<li><p>可保留运行堆栈，函数上下文随着<code>Async函数</code>的执行而存在，执行完成就消失</p>
</li>
</ul>
<h2 id="ES2018"><a href="#ES2018" class="headerlink" title="ES2018"></a>ES2018</h2><h3 id="字符串扩展-2"><a href="#字符串扩展-2" class="headerlink" title="字符串扩展"></a>字符串扩展</h3><ul>
<li><input checked disabled type="checkbox"> <strong>放松对标签模板里字符串转义的限制</strong>：遇到不合法的字符串转义返回<code>undefined</code>，并且从<code>raw</code>上可获取原字符串</li>
</ul>
<h3 id="对象扩展-2"><a href="#对象扩展-2" class="headerlink" title="对象扩展"></a>对象扩展</h3><ul>
<li><input checked disabled type="checkbox"> <strong>扩展运算符(…)</strong>：转换对象为用逗号分隔的参数序列(<code>{ ...obj }</code>，相当于<code>rest/spread参数</code>的逆运算)</li>
</ul>
<blockquote>
<p>扩展应用</p>
</blockquote>
<ul>
<li>克隆对象：<code>const obj = { __proto__: Object.getPrototypeOf(obj1), ...obj1 }</code></li>
<li>合并对象：<code>const obj = { ...obj1, ...obj2 }</code></li>
<li>转换字符串为对象：<code>{ ...&quot;hello&quot; }</code></li>
<li>转换数组为对象：<code>{ ...[1, 2] }</code></li>
<li>与对象解构赋值结合：<code>const { x, ...rest/spread } = { x: 1, y: 2, z: 3 }</code>(不能复制继承自原型对象的属性)</li>
<li>修改现有对象部分属性：<code>const obj = { x: 1, ...{ x: 2 } }</code></li>
</ul>
<h3 id="正则扩展-1"><a href="#正则扩展-1" class="headerlink" title="正则扩展"></a>正则扩展</h3><ul>
<li><input checked disabled type="checkbox"> <p><strong>s修饰符</strong>：dotAll模式修饰符，使<code>.</code>匹配任意单个字符(<code>dotAll模式</code>)</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>dotAll</strong>：是否设置<code>s修饰符</code></p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>后行断言</strong>：<code>x</code>只有在<code>y</code>后才匹配</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>后行否定断言</strong>：<code>x</code>只有不在<code>y</code>后才匹配</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>Unicode属性转义</strong>：匹配符合<code>Unicode某种属性</code>的所有字符</p>
</li>
<li><ul>
<li>正向匹配：<code>\p{PropRule}</code></li>
<li>反向匹配：<code>\P{PropRule}</code></li>
<li>限制：<code>\p{...}</code>和<code>\P{...}</code>只对<code>Unicode字符</code>有效，使用时需加上<code>u修饰符</code></li>
</ul>
</li>
<li><input checked disabled type="checkbox"> <p><strong>具名组匹配</strong>：为每组匹配指定名字(<code>?</code>)</p>
</li>
<li><ul>
<li>声明：<code>const time = &quot;2017-09-11&quot;</code>、<code>const regexp = /(?\d{4})-(?\d{2})-(?\d{2})/u</code></li>
<li>匹配：<code>time.replace(regexp, &quot;$/$/$&quot;)</code></li>
<li>形式：<code>str.exec().groups.GroupName</code></li>
<li>解构赋值替换</li>
</ul>
</li>
</ul>
<h3 id="Promise-1"><a href="#Promise-1" class="headerlink" title="Promise"></a>Promise</h3><ul>
<li><input checked disabled type="checkbox"> <strong>finally()</strong>：指定不管最后状态如何都会执行的回调函数</li>
</ul>
<h3 id="Async-1"><a href="#Async-1" class="headerlink" title="Async"></a>Async</h3><ul>
<li><input checked disabled type="checkbox"> <strong>异步迭代器(for-wait-of)</strong>：，循环等待每个<code>Promise对象</code>变为<code>resolved状态</code>才进入下一步</li>
</ul>
<h2 id="ES2019"><a href="#ES2019" class="headerlink" title="ES2019"></a>ES2019</h2><h3 id="字符串扩展-3"><a href="#字符串扩展-3" class="headerlink" title="字符串扩展"></a>字符串扩展</h3><ul>
<li><input checked disabled type="checkbox"> <strong>直接输入U+2028和U+2029</strong>：字符串可直接输入<code>行分隔符</code>和<code>段分隔符</code></li>
<li><input checked disabled type="checkbox"> <strong>JSON.stringify()改造</strong>：可返回不符合UTF-8标准的字符串</li>
<li><input checked disabled type="checkbox"> <strong>trimStart()</strong>：消除字符串头部空格，返回新字符串</li>
<li><input checked disabled type="checkbox"> <strong>trimEnd()</strong>：消除字符串尾部空格，返回新字符串</li>
</ul>
<h3 id="对象扩展-3"><a href="#对象扩展-3" class="headerlink" title="对象扩展"></a>对象扩展</h3><ul>
<li><input checked disabled type="checkbox"> <strong>Object.fromEntries()</strong>：返回以键和值组成的对象(<code>Object.entries()</code>的逆操作)</li>
</ul>
<h3 id="数组扩展-2"><a href="#数组扩展-2" class="headerlink" title="数组扩展"></a>数组扩展</h3><ul>
<li><input checked disabled type="checkbox"> <strong>flat()</strong>：扁平化数组，返回新数组</li>
<li><input checked disabled type="checkbox"> <strong>flatMap()</strong>：映射且扁平化数组，返回新数组(只能展开一层数组)</li>
</ul>
<h3 id="函数扩展-2"><a href="#函数扩展-2" class="headerlink" title="函数扩展"></a>函数扩展</h3><ul>
<li><input checked disabled type="checkbox"> <strong>toString()改造</strong>：返回函数原始代码(与编码一致)</li>
<li><input checked disabled type="checkbox"> <strong>catch()参数可省略</strong>：<code>catch()</code>中的参数可省略</li>
</ul>
<h3 id="Symbol-1"><a href="#Symbol-1" class="headerlink" title="Symbol"></a>Symbol</h3><ul>
<li><input checked disabled type="checkbox"> <strong>description</strong>：返回<code>Symbol值</code>的描述</li>
</ul>
<h2 id="ES提案"><a href="#ES提案" class="headerlink" title="ES提案"></a>ES提案</h2><h3 id="声明-2"><a href="#声明-2" class="headerlink" title="声明"></a>声明</h3><ul>
<li><input checked disabled type="checkbox"> <strong>globalThis对象</strong>：作为顶层对象，指向全局环境下的<code>this</code></li>
<li><input checked disabled type="checkbox"> <strong>do表达式</strong>：封装块级作用域的操作，返回内部最后执行表达式的值(<code>do{}</code>)</li>
<li><input checked disabled type="checkbox"> <strong>throw表达式</strong>：直接使用<code>throw new Error()</code>，无需<code>()</code>或<code>{}</code>包括</li>
<li><input checked disabled type="checkbox"> <strong>!#命令</strong>：指定脚本执行器(写在文件首行)</li>
</ul>
<h3 id="数值扩展-2"><a href="#数值扩展-2" class="headerlink" title="数值扩展"></a>数值扩展</h3><ul>
<li><input checked disabled type="checkbox"> <strong>数值分隔符(_)</strong>：使用<code>_</code>作为千分位分隔符(增加数值的可读性)</li>
<li><input checked disabled type="checkbox"> <strong>BigInt()</strong>：创建任何位数的整数(新增的数据类型，使用<code>n</code>结尾)</li>
</ul>
<h3 id="对象扩展-4"><a href="#对象扩展-4" class="headerlink" title="对象扩展"></a>对象扩展</h3><ul>
<li><input checked disabled type="checkbox"> <strong>链判断操作符(?.)</strong>：是否存在对象属性(不存在返回<code>undefined</code>且不再往下执行)</li>
<li><input checked disabled type="checkbox"> <strong>空判断操作符(??)</strong>：是否值为<code>undefined</code>或<code>null</code>，是则使用默认值</li>
</ul>
<h3 id="函数扩展-3"><a href="#函数扩展-3" class="headerlink" title="函数扩展"></a>函数扩展</h3><ul>
<li><input checked disabled type="checkbox"> <p><strong>函数部分执行</strong>：复用函数功能(<code>?</code>表示单个参数占位符，<code>...</code>表示多个参数占位符)</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>管道操作符(|&gt;)</strong>：把左边表达式的值传入右边的函数进行求值(<code>f(x)</code> =&gt; <code>x |&gt; f</code>)</p>
</li>
<li><input checked disabled type="checkbox"> <p><strong>绑定运算符(::)</strong>：函数绑定(左边是对象右边是函数，取代<code>bind</code>、<code>apply</code>、<code>call</code>调用)</p>
</li>
<li><ul>
<li>bind：<code>bar.bind(foo)</code> =&gt; <code>foo::bar</code></li>
<li>apply：<code>bar.apply(foo, arguments)</code> =&gt; <code>foo::bar(...arguments)</code></li>
</ul>
</li>
</ul>
<h3 id="Proxy-1"><a href="#Proxy-1" class="headerlink" title="Proxy"></a>Proxy</h3><ul>
<li><input checked disabled type="checkbox"> <strong>Promise.try()</strong>：不想区分是否同步异步函数，包装函数为实例，使用<code>then()</code>指定下一步流程，使用<code>catch()</code>捕获错误</li>
</ul>
<h3 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h3><ul>
<li>定义：提供<code>沙箱功能</code>，允许隔离代码，防止被隔离的代码拿到全局对象</li>
<li>声明：<code>new Realm().global</code></li>
</ul>
<h3 id="Class-1"><a href="#Class-1" class="headerlink" title="Class"></a>Class</h3><ul>
<li><input checked disabled type="checkbox"> <strong>静态属性</strong>：使用<code>static</code>定义属性，该属性<code>不会被实例继承</code>，只能通过类来调用</li>
<li><input checked disabled type="checkbox"> <strong>私有属性</strong>：使用<code>#</code>定义属性，该属性只能在类内部访问</li>
<li><input checked disabled type="checkbox"> <strong>私有方法</strong>：使用<code>#</code>定义方法，该方法只能在类内部访问</li>
<li><input checked disabled type="checkbox"> <strong>装饰器</strong>：使用<code>@</code>注释或修改类和类方法</li>
</ul>
<h3 id="Module-1"><a href="#Module-1" class="headerlink" title="Module"></a>Module</h3><ul>
<li><input checked disabled type="checkbox"> <p><strong>import()</strong>：动态导入(返回<code>Primise</code>)</p>
</li>
<li><ul>
<li>背景：<code>import命令</code>被JS引擎静态分析，先于模块内的其他语句执行，无法取代<code>require()</code>的动态加载功能，提案建议引入<code>import()</code>来代替<code>require()</code></li>
<li>位置：可在任何地方使用</li>
<li>区别：<code>require()</code>是<strong>同步加载</strong>，<code>import()</code>是<strong>异步加载</strong></li>
<li>场景：按需加载、条件加载、模块路径动态化</li>
</ul>
</li>
<li><input checked disabled type="checkbox"> <p><strong>import.meta</strong>：返回脚本元信息</p>
</li>
</ul>
<h3 id="Async-2"><a href="#Async-2" class="headerlink" title="Async"></a>Async</h3><ul>
<li><input checked disabled type="checkbox"> <strong>顶层Await</strong>：允许在模块的顶层独立使用<code>await命令</code>(借用<code>await</code>解决模块异步加载的问题)</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://supertinypeanut.github.io/blog/2020/02/21/es6/" data-id="ckmm8vac0002k85qse9jgenzz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/ECMAScript-6/" rel="tag">ECMAScript 6</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-常用的JS开发技巧(I)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/02/17/%E5%B8%B8%E7%94%A8%E7%9A%84JS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7(I)/" class="article-date">
  <time datetime="2020-02-17T10:10:10.000Z" itemprop="datePublished">2020-02-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/02/17/%E5%B8%B8%E7%94%A8%E7%9A%84JS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7(I)/">常用的JS开发技巧(I)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li>「String Skill」：字符串技巧</li>
<li>「Number Skill」：数值技巧</li>
<li>「Boolean Skill」：布尔技巧</li>
<li>「Array Skill」：数组技巧</li>
<li>「Object Skill」：对象技巧</li>
<li>「Function Skill」：函数技巧</li>
<li>「DOM Skill」：DOM技巧</li>
</ul>
<p>备注</p>
<ul>
<li>代码只作演示用途，不会详细说明ES6语法</li>
<li>如有不明白的语法问题可以参考阮一峰老师的《ES6标准入门》</li>
<li>《ES6标准入门》一直保持更新，建议收藏，平时查看</li>
</ul>
<h3 id="String-Skill"><a href="#String-Skill" class="headerlink" title="String Skill"></a>String Skill</h3><h5 id="对比时间"><a href="#对比时间" class="headerlink" title="对比时间"></a>对比时间</h5><blockquote>
<p>时间个位数形式需补0</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> time1 = <span class="string">"2019-02-14 21:00:00"</span>;</span><br><span class="line"><span class="keyword">const</span> time2 = <span class="string">"2019-05-01 09:00:00"</span>;</span><br><span class="line"><span class="keyword">const</span> overtime = time1 &gt; time2;</span><br><span class="line"><span class="comment">// overtime =&gt; false</span></span><br></pre></td></tr></table></figure>

<h5 id="格式化金钱"><a href="#格式化金钱" class="headerlink" title="格式化金钱"></a>格式化金钱</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ThousandNum = <span class="function"><span class="params">num</span> =&gt;</span> num.toString().replace(<span class="regexp">/\B(?=(\d&#123;3&#125;)+(?!\d))/g</span>, <span class="string">","</span>);</span><br><span class="line"><span class="keyword">const</span> money = ThousandNum(<span class="number">20190214</span>);</span><br><span class="line"><span class="comment">// money =&gt; "20,190,214"</span></span><br></pre></td></tr></table></figure>

<h5 id="生成随机ID"><a href="#生成随机ID" class="headerlink" title="生成随机ID"></a>生成随机ID</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RandomId = <span class="function"><span class="params">len</span> =&gt;</span> <span class="built_in">Math</span>.random().toString(<span class="number">36</span>).substr(<span class="number">3</span>, len);</span><br><span class="line"><span class="keyword">const</span> id = RandomId(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// id =&gt; "jg7zpgiqva"</span></span><br></pre></td></tr></table></figure>

<h5 id="生成随机HEX色值"><a href="#生成随机HEX色值" class="headerlink" title="生成随机HEX色值"></a>生成随机HEX色值</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RandomColor = <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">"#"</span> + <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">0xffffff</span>).toString(<span class="number">16</span>).padEnd(<span class="number">6</span>, <span class="string">"0"</span>);</span><br><span class="line"><span class="keyword">const</span> color = RandomColor();</span><br><span class="line"><span class="comment">// color =&gt; "#f03665"</span></span><br></pre></td></tr></table></figure>

<h5 id="生成星级评分"><a href="#生成星级评分" class="headerlink" title="生成星级评分"></a>生成星级评分</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> StartScore = <span class="function"><span class="params">rate</span> =&gt;</span> <span class="string">"★★★★★☆☆☆☆☆"</span>.slice(<span class="number">5</span> - rate, <span class="number">10</span> - rate);</span><br><span class="line"><span class="keyword">const</span> start = StartScore(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// start =&gt; "★★★"</span></span><br></pre></td></tr></table></figure>

<h5 id="操作URL查询参数"><a href="#操作URL查询参数" class="headerlink" title="操作URL查询参数"></a>操作URL查询参数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> params = <span class="keyword">new</span> URLSearchParams(location.search.replace(<span class="regexp">/\?/ig</span>, <span class="string">""</span>)); <span class="comment">// location.search = "?name=young&amp;sex=male"</span></span><br><span class="line">params.has(<span class="string">"young"</span>); <span class="comment">// true</span></span><br><span class="line">params.get(<span class="string">"sex"</span>); <span class="comment">// "male"</span></span><br></pre></td></tr></table></figure>

<h3 id="Number-Skill"><a href="#Number-Skill" class="headerlink" title="Number Skill"></a>Number Skill</h3><h5 id="取整"><a href="#取整" class="headerlink" title="取整"></a>取整</h5><blockquote>
<p>代替正数的<code>Math.floor()</code>，代替负数的<code>Math.ceil()</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num1 = ~~ <span class="number">1.69</span>;</span><br><span class="line"><span class="keyword">const</span> num2 = <span class="number">1.69</span> | <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> num3 = <span class="number">1.69</span> &gt;&gt; <span class="number">0</span>;</span><br><span class="line"><span class="comment">// num1 num2 num3 =&gt; 1 1 1</span></span><br></pre></td></tr></table></figure>

<h5 id="补零"><a href="#补零" class="headerlink" title="补零"></a>补零</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> FillZero = <span class="function">(<span class="params">num, len</span>) =&gt;</span> num.toString().padStart(len, <span class="string">"0"</span>);</span><br><span class="line"><span class="keyword">const</span> num = FillZero(<span class="number">169</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// num =&gt; "00169"</span></span><br></pre></td></tr></table></figure>

<h5 id="转数值"><a href="#转数值" class="headerlink" title="转数值"></a>转数值</h5><blockquote>
<p>只对<code>null、&quot;&quot;、false、数值字符串</code>有效</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num1 = +<span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> num2 = +<span class="string">""</span>;</span><br><span class="line"><span class="keyword">const</span> num3 = +<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">const</span> num4 = +<span class="string">"169"</span>;</span><br><span class="line"><span class="comment">// num1 num2 num3 num4 =&gt; 0 0 0 169</span></span><br></pre></td></tr></table></figure>

<h5 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timestamp = +<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"2019-02-14"</span>);</span><br><span class="line"><span class="comment">// timestamp =&gt; 1550102400000</span></span><br></pre></td></tr></table></figure>

<h5 id="精确小数"><a href="#精确小数" class="headerlink" title="精确小数"></a>精确小数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RoundNum = <span class="function">(<span class="params">num, decimal</span>) =&gt;</span> <span class="built_in">Math</span>.round(num * <span class="number">10</span> ** decimal) / <span class="number">10</span> ** decimal;</span><br><span class="line"><span class="keyword">const</span> num = RoundNum(<span class="number">1.69</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// num =&gt; 1.7</span></span><br></pre></td></tr></table></figure>

<h5 id="判断奇偶"><a href="#判断奇偶" class="headerlink" title="判断奇偶"></a>判断奇偶</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OddEven = <span class="function"><span class="params">num</span> =&gt;</span> !!(num &amp; <span class="number">1</span>) ? <span class="string">"odd"</span> : <span class="string">"even"</span>;</span><br><span class="line"><span class="keyword">const</span> num = OddEven(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// num =&gt; "even"</span></span><br></pre></td></tr></table></figure>

<h5 id="取最小最大值"><a href="#取最小最大值" class="headerlink" title="取最小最大值"></a>取最小最大值</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> min = <span class="built_in">Math</span>.min(...arr);</span><br><span class="line"><span class="keyword">const</span> max = <span class="built_in">Math</span>.max(...arr);</span><br><span class="line"><span class="comment">// min max =&gt; 0 2</span></span><br></pre></td></tr></table></figure>

<h5 id="生成范围随机数"><a href="#生成范围随机数" class="headerlink" title="生成范围随机数"></a>生成范围随机数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RandomNum = <span class="function">(<span class="params">min, max</span>) =&gt;</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min + <span class="number">1</span>)) + min;</span><br><span class="line"><span class="keyword">const</span> num = RandomNum(<span class="number">1</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Boolean-Skill"><a href="#Boolean-Skill" class="headerlink" title="Boolean Skill"></a>Boolean Skill</h3><h5 id="短路运算符"><a href="#短路运算符" class="headerlink" title="短路运算符"></a>短路运算符</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = d &amp;&amp; <span class="number">1</span>; <span class="comment">// 满足条件赋值：取假运算，从左到右依次判断，遇到假值返回假值，后面不再执行，否则返回最后一个真值</span></span><br><span class="line"><span class="keyword">const</span> b = d || <span class="number">1</span>; <span class="comment">// 默认赋值：取真运算，从左到右依次判断，遇到真值返回真值，后面不再执行，否则返回最后一个假值</span></span><br><span class="line"><span class="keyword">const</span> c = !d; <span class="comment">// 取假赋值：单个表达式转换为true则返回false，否则返回true</span></span><br></pre></td></tr></table></figure>

<h5 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h5><blockquote>
<p>可判断类型：undefined、null、string、number、boolean、array、object、symbol、date、regexp、function、asyncfunction、arguments、set、map、weakset、weakmap</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DataType</span>(<span class="params">tgt, type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dataType = <span class="built_in">Object</span>.prototype.toString.call(tgt).replace(<span class="regexp">/\[object (\w+)\]/</span>, <span class="string">"$1"</span>).toLowerCase();</span><br><span class="line">    <span class="keyword">return</span> type ? dataType === type : dataType;</span><br><span class="line">&#125;</span><br><span class="line">DataType(<span class="string">"young"</span>); <span class="comment">// "string"</span></span><br><span class="line">DataType(<span class="number">20190214</span>); <span class="comment">// "number"</span></span><br><span class="line">DataType(<span class="literal">true</span>); <span class="comment">// "boolean"</span></span><br><span class="line">DataType([], <span class="string">"array"</span>); <span class="comment">// true</span></span><br><span class="line">DataType(&#123;&#125;, <span class="string">"array"</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h5 id="是否为空数组"><a href="#是否为空数组" class="headerlink" title="是否为空数组"></a>是否为空数组</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [];</span><br><span class="line"><span class="keyword">const</span> flag = <span class="built_in">Array</span>.isArray(arr) &amp;&amp; !arr.length;</span><br><span class="line"><span class="comment">// flag =&gt; true</span></span><br></pre></td></tr></table></figure>

<h5 id="是否为空对象"><a href="#是否为空对象" class="headerlink" title="是否为空对象"></a>是否为空对象</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> flag = DataType(obj, <span class="string">"object"</span>) &amp;&amp; !<span class="built_in">Object</span>.keys(obj).length;</span><br><span class="line"><span class="comment">// flag =&gt; true</span></span><br></pre></td></tr></table></figure>

<h5 id="满足条件时执行"><a href="#满足条件时执行" class="headerlink" title="满足条件时执行"></a>满足条件时执行</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flagA = <span class="literal">true</span>; <span class="comment">// 条件A</span></span><br><span class="line"><span class="keyword">const</span> flagB = <span class="literal">false</span>; <span class="comment">// 条件B</span></span><br><span class="line">(flagA || flagB) &amp;&amp; Func(); <span class="comment">// 满足A或B时执行</span></span><br><span class="line">(flagA || !flagB) &amp;&amp; Func(); <span class="comment">// 满足A或不满足B时执行</span></span><br><span class="line">flagA &amp;&amp; flagB &amp;&amp; Func(); <span class="comment">// 同时满足A和B时执行</span></span><br><span class="line">flagA &amp;&amp; !flagB &amp;&amp; Func(); <span class="comment">// 满足A且不满足B时执行</span></span><br></pre></td></tr></table></figure>

<h5 id="为非假值时执行"><a href="#为非假值时执行" class="headerlink" title="为非假值时执行"></a>为非假值时执行</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flag = <span class="literal">false</span>; <span class="comment">// undefined、null、""、0、false、NaN</span></span><br><span class="line">!flag &amp;&amp; Func();</span><br></pre></td></tr></table></figure>

<h5 id="数组不为空时执行"><a href="#数组不为空时执行" class="headerlink" title="数组不为空时执行"></a>数组不为空时执行</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.length &amp;&amp; Func();</span><br></pre></td></tr></table></figure>

<h5 id="对象不为空时执行"><a href="#对象不为空时执行" class="headerlink" title="对象不为空时执行"></a>对象不为空时执行</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">0</span>, <span class="attr">b</span>: <span class="number">1</span>, <span class="attr">c</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.keys(obj).length &amp;&amp; Func();</span><br></pre></td></tr></table></figure>

<h5 id="函数退出代替条件分支退出"><a href="#函数退出代替条件分支退出" class="headerlink" title="函数退出代替条件分支退出"></a>函数退出代替条件分支退出</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">    Func();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 换成</span></span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">    <span class="keyword">return</span> Func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="switch-case使用区间"><a href="#switch-case使用区间" class="headerlink" title="switch/case使用区间"></a>switch/case使用区间</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> age = <span class="number">26</span>;</span><br><span class="line"><span class="keyword">switch</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">isNaN</span>(age):</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"not a number"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> (age &lt; <span class="number">18</span>):</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"under age"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> (age &gt;= <span class="number">18</span>):</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"adult"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"please set your age"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Array-Skill"><a href="#Array-Skill" class="headerlink" title="Array Skill"></a>Array Skill</h3><h5 id="克隆数组"><a href="#克隆数组" class="headerlink" title="克隆数组"></a>克隆数组</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> arr = [..._arr];</span><br><span class="line"><span class="comment">// arr =&gt; [0, 1, 2]</span></span><br></pre></td></tr></table></figure>

<h5 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> arr = [...arr1, ...arr2];</span><br><span class="line"><span class="comment">// arr =&gt; [0, 1, 2, 3, 4, 5];</span></span><br></pre></td></tr></table></figure>

<h5 id="去重数组"><a href="#去重数组" class="headerlink" title="去重数组"></a>去重数组</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [...new <span class="built_in">Set</span>([<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="literal">null</span>, <span class="literal">null</span>])];</span><br><span class="line"><span class="comment">// arr =&gt; [0, 1, null]</span></span><br></pre></td></tr></table></figure>

<h5 id="混淆数组"><a href="#混淆数组" class="headerlink" title="混淆数组"></a>混淆数组</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].slice().sort(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Math</span>.random() - <span class="number">.5</span>);</span><br><span class="line"><span class="comment">// arr =&gt; [3, 4, 0, 5, 1, 2]</span></span><br></pre></td></tr></table></figure>

<h5 id="清空数组"><a href="#清空数组" class="headerlink" title="清空数组"></a>清空数组</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.length = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// arr =&gt; []</span></span><br></pre></td></tr></table></figure>

<h5 id="截断数组"><a href="#截断数组" class="headerlink" title="截断数组"></a>截断数组</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.length = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// arr =&gt; [0, 1]</span></span><br></pre></td></tr></table></figure>

<h5 id="交换赋值"><a href="#交换赋值" class="headerlink" title="交换赋值"></a>交换赋值</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line">[a, b] = [b, a];</span><br><span class="line"><span class="comment">// a b =&gt; 1 0</span></span><br></pre></td></tr></table></figure>

<h5 id="过滤空值"><a href="#过滤空值" class="headerlink" title="过滤空值"></a>过滤空值</h5><blockquote>
<p>空值：undefined、null、””、0、false、NaN</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="literal">undefined</span>, <span class="literal">null</span>, <span class="string">""</span>, <span class="number">0</span>, <span class="literal">false</span>, <span class="literal">NaN</span>, <span class="number">1</span>, <span class="number">2</span>].filter(<span class="built_in">Boolean</span>);</span><br><span class="line"><span class="comment">// arr =&gt; [1, 2]</span></span><br></pre></td></tr></table></figure>

<h5 id="异步累计"><a href="#异步累计" class="headerlink" title="异步累计"></a>异步累计</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">Func</span>(<span class="params">deps</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> deps.reduce(<span class="keyword">async</span>(t, v) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> dep = <span class="keyword">await</span> t;</span><br><span class="line">        <span class="keyword">const</span> version = <span class="keyword">await</span> Todo(v);</span><br><span class="line">        dep[v] = version;</span><br><span class="line">        <span class="keyword">return</span> dep;</span><br><span class="line">    &#125;, <span class="built_in">Promise</span>.resolve(&#123;&#125;));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> Func(); <span class="comment">// 需在async包围下使用</span></span><br></pre></td></tr></table></figure>

<h5 id="数组首部插入成员"><a href="#数组首部插入成员" class="headerlink" title="数组首部插入成员"></a>数组首部插入成员</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// 以下方法任选一种</span></span><br><span class="line">arr.unshift(<span class="number">0</span>);</span><br><span class="line">arr = [<span class="number">0</span>].concat(arr);</span><br><span class="line">arr = [<span class="number">0</span>, ...arr];</span><br><span class="line"><span class="comment">// arr =&gt; [0, 1, 2]</span></span><br></pre></td></tr></table></figure>

<h5 id="数组尾部插入成员"><a href="#数组尾部插入成员" class="headerlink" title="数组尾部插入成员"></a>数组尾部插入成员</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>, <span class="number">1</span>]; <span class="comment">// 以下方法任选一种</span></span><br><span class="line">arr.push(<span class="number">2</span>);</span><br><span class="line">arr.concat(<span class="number">2</span>);</span><br><span class="line">arr[arr.length] = <span class="number">2</span>;</span><br><span class="line">arr = [...arr, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// arr =&gt; [0, 1, 2]</span></span><br></pre></td></tr></table></figure>

<h5 id="统计数组成员个数"><a href="#统计数组成员个数" class="headerlink" title="统计数组成员个数"></a>统计数组成员个数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> count = arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> &#123;</span><br><span class="line">	t[v] = t[v] ? ++t[v] : <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line"><span class="comment">// count =&gt; &#123; 0: 1, 1: 2, 2: 3 &#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="解构数组成员嵌套"><a href="#解构数组成员嵌套" class="headerlink" title="解构数组成员嵌套"></a>解构数组成员嵌套</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>, <span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]];</span><br><span class="line"><span class="keyword">const</span> [a, b, [c, d, [e, f]]] = arr;</span><br><span class="line"><span class="comment">// a b c d e f =&gt; 0 1 2 3 4 5</span></span><br></pre></td></tr></table></figure>

<h5 id="解构数组成员别名"><a href="#解构数组成员别名" class="headerlink" title="解构数组成员别名"></a>解构数组成员别名</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="number">0</span>: a, <span class="number">1</span>: b, <span class="number">2</span>: c &#125; = arr;</span><br><span class="line"><span class="comment">// a b c =&gt; 0 1 2</span></span><br></pre></td></tr></table></figure>

<h5 id="解构数组成员默认值"><a href="#解构数组成员默认值" class="headerlink" title="解构数组成员默认值"></a>解构数组成员默认值</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> [a, b, c = <span class="number">3</span>, d = <span class="number">4</span>] = arr;</span><br><span class="line"><span class="comment">// a b c d =&gt; 0 1 2 4</span></span><br></pre></td></tr></table></figure>

<h5 id="获取随机数组成员"><a href="#获取随机数组成员" class="headerlink" title="获取随机数组成员"></a>获取随机数组成员</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> randomItem = arr[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * arr.length)];</span><br><span class="line"><span class="comment">// randomItem =&gt; 1</span></span><br></pre></td></tr></table></figure>

<h5 id="创建指定长度数组"><a href="#创建指定长度数组" class="headerlink" title="创建指定长度数组"></a>创建指定长度数组</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [...new <span class="built_in">Array</span>(<span class="number">3</span>).keys()];</span><br><span class="line"><span class="comment">// arr =&gt; [0, 1, 2]</span></span><br></pre></td></tr></table></figure>

<h5 id="创建指定长度且值相等的数组"><a href="#创建指定长度且值相等的数组" class="headerlink" title="创建指定长度且值相等的数组"></a>创建指定长度且值相等的数组</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// arr =&gt; [0, 0, 0]</span></span><br></pre></td></tr></table></figure>

<h5 id="reduce代替map和filter"><a href="#reduce代替map和filter" class="headerlink" title="reduce代替map和filter"></a>reduce代替map和filter</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// map</span></span><br><span class="line"><span class="keyword">const</span> arr = _arr.map(<span class="function"><span class="params">v</span> =&gt;</span> v * <span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> arr = _arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> &#123;</span><br><span class="line">    t.push(v * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;, []);</span><br><span class="line"><span class="comment">// arr =&gt; [0, 2, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// filter</span></span><br><span class="line"><span class="keyword">const</span> arr = _arr.filter(<span class="function"><span class="params">v</span> =&gt;</span> v &gt; <span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> arr = _arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> &#123;</span><br><span class="line">    v &gt; <span class="number">0</span> &amp;&amp; t.push(v);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;, []);</span><br><span class="line"><span class="comment">// arr =&gt; [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map和filter</span></span><br><span class="line"><span class="keyword">const</span> arr = _arr.map(<span class="function"><span class="params">v</span> =&gt;</span> v * <span class="number">2</span>).filter(<span class="function"><span class="params">v</span> =&gt;</span> v &gt; <span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> arr = _arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> &#123;</span><br><span class="line">    v = v * <span class="number">2</span>;</span><br><span class="line">    v &gt; <span class="number">2</span> &amp;&amp; t.push(v);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;, []);</span><br><span class="line"><span class="comment">// arr =&gt; [4]</span></span><br></pre></td></tr></table></figure>

<h3 id="Object-Skill"><a href="#Object-Skill" class="headerlink" title="Object Skill"></a>Object Skill</h3><h5 id="克隆对象"><a href="#克隆对象" class="headerlink" title="克隆对象"></a>克隆对象</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">const</span> <span class="string">_obj</span> <span class="string">=</span> <span class="string">&#123;</span> <span class="attr">a:</span> <span class="number">0</span><span class="string">,</span> <span class="attr">b:</span> <span class="number">1</span><span class="string">,</span> <span class="attr">c:</span> <span class="number">2</span> <span class="string">&#125;;</span> <span class="string">//</span> <span class="string">以下方法任选一种</span></span><br><span class="line"><span class="string">const</span> <span class="string">obj</span> <span class="string">=</span> <span class="string">&#123;</span> <span class="string">..._obj</span> <span class="string">&#125;;</span></span><br><span class="line"><span class="string">const</span> <span class="string">obj</span> <span class="string">=</span> <span class="string">JSON.parse(JSON.stringify(_obj));</span></span><br><span class="line"><span class="string">//</span> <span class="string">obj</span> <span class="string">=&gt;</span> <span class="string">&#123;</span> <span class="attr">a:</span> <span class="number">0</span><span class="string">,</span> <span class="attr">b:</span> <span class="number">1</span><span class="string">,</span> <span class="attr">c:</span> <span class="number">2</span> <span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="合并对象"><a href="#合并对象" class="headerlink" title="合并对象"></a>合并对象</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">0</span>, <span class="attr">b</span>: <span class="number">1</span>, <span class="attr">c</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">c</span>: <span class="number">3</span>, <span class="attr">d</span>: <span class="number">4</span>, <span class="attr">e</span>: <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj = &#123; ...obj1, ...obj2 &#125;;</span><br><span class="line"><span class="comment">// obj =&gt; &#123; a: 0, b: 1, c: 3, d: 4, e: 5 &#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h5><blockquote>
<p>获取环境变量时必用此方法，用它一直爽，一直用它一直爽</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> env = <span class="string">"prod"</span>;</span><br><span class="line"><span class="keyword">const</span> link = &#123;</span><br><span class="line">    dev: <span class="string">"Development Address"</span>,</span><br><span class="line">    test: <span class="string">"Testing Address"</span>,</span><br><span class="line">    prod: <span class="string">"Production Address"</span></span><br><span class="line">&#125;[env];</span><br><span class="line"><span class="comment">// link =&gt; "Production Address"</span></span><br></pre></td></tr></table></figure>

<h5 id="对象变量属性"><a href="#对象变量属性" class="headerlink" title="对象变量属性"></a>对象变量属性</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    a: <span class="number">0</span>,</span><br><span class="line">    b: <span class="number">1</span>,</span><br><span class="line">    [flag ? <span class="string">"c"</span> : <span class="string">"d"</span>]: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// obj =&gt; &#123; a: 0, b: 1, d: 2 &#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="创建纯空对象"><a href="#创建纯空对象" class="headerlink" title="创建纯空对象"></a>创建纯空对象</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">Object</span>.prototype.a = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// obj =&gt; &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="删除对象无用属性"><a href="#删除对象无用属性" class="headerlink" title="删除对象无用属性"></a>删除对象无用属性</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">0</span>, <span class="attr">b</span>: <span class="number">1</span>, <span class="attr">c</span>: <span class="number">2</span> &#125;; <span class="comment">// 只想拿b和c</span></span><br><span class="line"><span class="keyword">const</span> &#123; a, ...rest &#125; = obj;</span><br><span class="line"><span class="comment">// rest =&gt; &#123; b: 1, c: 2 &#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="解构对象属性嵌套"><a href="#解构对象属性嵌套" class="headerlink" title="解构对象属性嵌套"></a>解构对象属性嵌套</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">0</span>, <span class="attr">b</span>: <span class="number">1</span>, <span class="attr">c</span>: &#123; <span class="attr">d</span>: <span class="number">2</span>, <span class="attr">e</span>: <span class="number">3</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">c</span>: &#123; d, e &#125; &#125; = obj;</span><br><span class="line"><span class="comment">// d e =&gt; 2 3</span></span><br></pre></td></tr></table></figure>

<h5 id="解构对象属性别名"><a href="#解构对象属性别名" class="headerlink" title="解构对象属性别名"></a>解构对象属性别名</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">0</span>, <span class="attr">b</span>: <span class="number">1</span>, <span class="attr">c</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; a, <span class="attr">b</span>: d, <span class="attr">c</span>: e &#125; = obj;</span><br><span class="line"><span class="comment">// a d e =&gt; 0 1 2</span></span><br></pre></td></tr></table></figure>

<h5 id="解构对象属性默认值"><a href="#解构对象属性默认值" class="headerlink" title="解构对象属性默认值"></a>解构对象属性默认值</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">0</span>, <span class="attr">b</span>: <span class="number">1</span>, <span class="attr">c</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; a, b = <span class="number">2</span>, d = <span class="number">3</span> &#125; = obj;</span><br><span class="line"><span class="comment">// a b d =&gt; 0 1 3</span></span><br></pre></td></tr></table></figure>

<h3 id="Function-Skill"><a href="#Function-Skill" class="headerlink" title="Function Skill"></a>Function Skill</h3><h5 id="函数自执行"><a href="#函数自执行" class="headerlink" title="函数自执行"></a>函数自执行</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;(); <span class="comment">// 常用</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)(); <span class="comment">// 常用</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;()); <span class="comment">// 常用</span></span><br><span class="line">[<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;()];</span><br><span class="line"></span><br><span class="line">+ <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;();</span><br><span class="line">- <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;();</span><br><span class="line">~ <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;();</span><br><span class="line">! <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;();</span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;();</span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;();</span><br><span class="line"><span class="keyword">delete</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;();</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;();</span><br><span class="line"><span class="number">1</span> ^ <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;();</span><br><span class="line"><span class="number">1</span> &gt; <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;();</span><br></pre></td></tr></table></figure>

<h5 id="隐式返回值"><a href="#隐式返回值" class="headerlink" title="隐式返回值"></a>隐式返回值</h5><blockquote>
<p>只能用于<code>单语句返回值箭头函数</code>，如果返回值是对象必须使用<code>()</code>包住</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Func = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"I Love "</span> + name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 换成</span></span><br><span class="line"><span class="keyword">const</span> Func = <span class="function"><span class="params">name</span> =&gt;</span> <span class="string">"I Love "</span> + name;</span><br></pre></td></tr></table></figure>

<h5 id="一次性函数"><a href="#一次性函数" class="headerlink" title="一次性函数"></a>一次性函数</h5><blockquote>
<p>适用于运行一些只需执行一次的初始化代码</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"x"</span>);</span><br><span class="line">    Func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"y"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="惰性载入函数"><a href="#惰性载入函数" class="headerlink" title="惰性载入函数"></a>惰性载入函数</h5><blockquote>
<p>函数内判断分支较多较复杂时可大大节约资源开销</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a === b) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"x"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"y"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 换成</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a === b) &#123;</span><br><span class="line">        Func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"x"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"y"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="检测非空参数"><a href="#检测非空参数" class="headerlink" title="检测非空参数"></a>检测非空参数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IsRequired</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"param is required"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Func</span>(<span class="params">name = IsRequired(</span>)) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"I Love "</span> + name);</span><br><span class="line">&#125;</span><br><span class="line">Func(); <span class="comment">// "param is required"</span></span><br><span class="line">Func(<span class="string">"You"</span>); <span class="comment">// "I Love You"</span></span><br></pre></td></tr></table></figure>

<h5 id="字符串创建函数"><a href="#字符串创建函数" class="headerlink" title="字符串创建函数"></a>字符串创建函数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Func = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"name"</span>, <span class="string">"console.log(\"I Love \" + name)"</span>);</span><br></pre></td></tr></table></figure>

<h5 id="优雅处理错误信息"><a href="#优雅处理错误信息" class="headerlink" title="优雅处理错误信息"></a>优雅处理错误信息</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Func();</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    location.href = <span class="string">"https://stackoverflow.com/search?q=[js]+"</span> + e.message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="优雅处理Async-Await参数"><a href="#优雅处理Async-Await参数" class="headerlink" title="优雅处理Async/Await参数"></a>优雅处理Async/Await参数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AsyncTo</span>(<span class="params">promise</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> promise.then(<span class="function"><span class="params">data</span> =&gt;</span> [<span class="literal">null</span>, data]).catch(<span class="function"><span class="params">err</span> =&gt;</span> [err]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> [err, res] = <span class="keyword">await</span> AsyncTo(Func());</span><br></pre></td></tr></table></figure>

<h5 id="优雅处理多个函数返回值"><a href="#优雅处理多个函数返回值" class="headerlink" title="优雅处理多个函数返回值"></a>优雅处理多个函数返回值</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">        fetch(<span class="string">"/user"</span>),</span><br><span class="line">        fetch(<span class="string">"/comment"</span>)</span><br><span class="line">    ]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> [user, comment] = <span class="keyword">await</span> Func(); <span class="comment">// 需在async包围下使用</span></span><br></pre></td></tr></table></figure>

<h3 id="DOM-Skill"><a href="#DOM-Skill" class="headerlink" title="DOM Skill"></a>DOM Skill</h3><h5 id="显示全部DOM边框"><a href="#显示全部DOM边框" class="headerlink" title="显示全部DOM边框"></a>显示全部DOM边框</h5><blockquote>
<p>调试页面元素边界时使用</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[].forEach.call($$(<span class="string">"*"</span>), dom =&gt; &#123;</span><br><span class="line">    dom.style.outline = <span class="string">"1px solid #"</span> + (~~(<span class="built_in">Math</span>.random() * (<span class="number">1</span> &lt;&lt; <span class="number">24</span>))).toString(<span class="number">16</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="自适应页面"><a href="#自适应页面" class="headerlink" title="自适应页面"></a>自适应页面</h5><blockquote>
<p>页面基于一张设计图但需做多款机型自适应，元素尺寸使用<code>rem</code>进行设置</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AutoResponse</span>(<span class="params">width = <span class="number">750</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> target = <span class="built_in">document</span>.documentElement;</span><br><span class="line">    target.clientWidth &gt;= <span class="number">600</span></span><br><span class="line">        ? (target.style.fontSize = <span class="string">"80px"</span>)</span><br><span class="line">        : (target.style.fontSize = target.clientWidth / width * <span class="number">100</span> + <span class="string">"px"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="过滤XSS"><a href="#过滤XSS" class="headerlink" title="过滤XSS"></a>过滤XSS</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FilterXss</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> elem = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">    elem.innerText = content;</span><br><span class="line">    <span class="keyword">const</span> result = elem.innerHTML;</span><br><span class="line">    elem = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="存取LocalStorage"><a href="#存取LocalStorage" class="headerlink" title="存取LocalStorage"></a>存取LocalStorage</h5><blockquote>
<p>反序列化取，序列化存</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> love = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">"love"</span>));</span><br><span class="line">localStorage.setItem(<span class="string">"love"</span>, <span class="built_in">JSON</span>.stringify(<span class="string">"I Love You"</span>));</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后送大家一个键盘！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="params">_</span>=&gt;</span>[...<span class="string">"`1234567890-=~~QWERTYUIOP[]\\~ASDFGHJKL;'~~ZXCVBNM,./~"</span>].map(<span class="function"><span class="params">x</span>=&gt;</span>(o+=<span class="string">`/<span class="subst">$&#123;b=<span class="string">'_'</span>.repeat(w=x&lt;y?<span class="number">2</span>:<span class="string">' 667699'</span>[x=[<span class="string">"Bs"</span>,<span class="string">"Tab"</span>,<span class="string">"Caps"</span>,<span class="string">"Enter"</span>][p++]||<span class="string">'Shift'</span>,p])&#125;</span>\\|`</span>,m+=y+(x+<span class="string">'    '</span>).slice(<span class="number">0</span>,w)+y+y,n+=y+b+y+y,l+=<span class="string">' __'</span>+b)[<span class="number">73</span>]&amp;&amp;(k.push(l,m,n,o),l=<span class="string">''</span>,m=n=o=y),m=n=o=y=<span class="string">'|'</span>,p=l=k=[])&amp;&amp;k.join<span class="string">`</span></span><br><span class="line"><span class="string">`</span>)()</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://supertinypeanut.github.io/blog/2020/02/17/%E5%B8%B8%E7%94%A8%E7%9A%84JS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7(I)/" data-id="ckmm8va76001z85qsaa7kba8n" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-type-definition" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/02/17/type-definition/" class="article-date">
  <time datetime="2020-02-17T10:10:10.000Z" itemprop="datePublished">2020-02-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/02/17/type-definition/">类型定义文件(*.d.ts)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="类型定义文件"><a href="#类型定义文件" class="headerlink" title="类型定义文件"></a>类型定义文件</h2><p>在 TypeScript 中，我们可以很简单的，在代码编写中定义类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IBaseModel &#123;</span><br><span class="line">  say(keys: <span class="built_in">string</span>[] | <span class="literal">null</span>): object</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> User <span class="keyword">implements</span> IBaseModel &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是主流的库都是 JavaScript 编写的，TypeScript 身为 JavaScript 的超集，自然需要考虑到如何让 JS 库也能定义静态类型。</p>
<p>TypeScript 经过了一系列的摸索，先后提出了 <a href="https://tasaid.com/link?url=https%3A%2F%2Fgithub.com%2FDefinitelyTyped%2Ftsd" target="_blank" rel="noopener">tsd</a>(已废弃)、<a href="https://tasaid.com/link?url=https%3A%2F%2Fgithub.com%2Ftypings%2Ftypings" target="_blank" rel="noopener">typings</a>(已废弃)，最终在 TypeScript 2.0 的时候重新整理了类型定义，提出了 <a href="https://tasaid.com/link?url=https%3A%2F%2Fgithub.com%2FDefinitelyTyped%2FDefinitelyTyped" target="_blank" rel="noopener">DefinitelyTyped</a>。</p>
<p><a href="https://tasaid.com/link?url=https%3A%2F%2Fgithub.com%2FDefinitelyTyped%2FDefinitelyTyped" target="_blank" rel="noopener">DefinitelyTyped</a> 就是让你把 “类型定义文件(*.d.ts)”，发布到 <code>npm</code> 中，配合编辑器(或插件)，就能够检测到 JS 库中的静态类型。</p>
<p>类型定义文件的以 <code>.d.ts</code> 结尾，里面主要用来定义类型。</p>
<p>例如这是 <a href="https://tasaid.com/link?url=https%3A%2F%2Fgithub.com%2FDefinitelyTyped%2FDefinitelyTyped%2Ftree%2Fmaster%2Ftypes%2Fjquery" target="_blank" rel="noopener">jQuery 的类型定义文件</a> 中一段代码（为了方便理解做了一些改动）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 jQuery 需要用到的类型命名空间</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> JQuery &#123;</span><br><span class="line">    <span class="comment">// 定义基本使用的类型</span></span><br><span class="line">    <span class="keyword">type</span> Selector = <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">type</span> TypeOrArray&lt;T&gt; = T | T[];</span><br><span class="line">    <span class="keyword">type</span> htmlString = <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 jQuery 接口，jquery 是一个 包含 Element 的集合</span></span><br><span class="line"><span class="keyword">interface</span> JQuery&lt;TElement <span class="keyword">extends</span> Node = HTMLElement&gt; <span class="keyword">extends</span> Iterable&lt;TElement&gt; &#123;</span><br><span class="line">    length: <span class="built_in">number</span>;</span><br><span class="line">    eq(index: <span class="built_in">number</span>): <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载</span></span><br><span class="line">    add(selector: JQuery.Selector, context: Element): <span class="keyword">this</span>;</span><br><span class="line">    add(selector: JQuery.Selector | JQuery.TypeOrArray&lt;Element&gt; | JQuery.htmlString | JQuery): <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    children(selector?: JQuery.Selector): <span class="keyword">this</span>;</span><br><span class="line">    css(propertyName: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">    html(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对模块 jquery 输出接口</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> 'jquery' &#123;</span><br><span class="line">    <span class="comment">// module 中要使用 export = 而不是 export default</span></span><br><span class="line">    <span class="keyword">export</span> = jQuery;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h2><p><code>*.d.ts</code> 编写起来非常简单，经过 TypeScript 良好的静态类型系统洗礼过后，语法学习成本非常低。</p>
<p>我们可以使用 <code>type</code> 用来定义类型变量：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本类型</span></span><br><span class="line"><span class="keyword">type</span> UserName = <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型赋值</span></span><br><span class="line"><span class="keyword">type</span> WebSite = <span class="built_in">string</span></span><br><span class="line"><span class="keyword">type</span> Tsaid = WebSite</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>type</code> 其实可以定义各种格式的类型，也可以和其他类型进行组合。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="keyword">type</span> User = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  website: WebSite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="keyword">type</span> say = <span class="function">(<span class="params">age: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="keyword">class</span> TaSaid &#123;</span><br><span class="line">  website: <span class="built_in">string</span>;</span><br><span class="line">  say: <span class="function">(<span class="params">age: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，我们也可以使用 <code>interface</code> 定义我们的复杂类型，在 TS 中我们也可以直接定义 <code>interface</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Application &#123;</span><br><span class="line">    init(): <span class="built_in">void</span></span><br><span class="line">    <span class="keyword">get</span>(key: <span class="built_in">string</span>): object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>interface</code> 和 <code>type</code>(或者说 <code>class</code>) 很像。</p>
<p>但是 <code>type</code> 的含义是定义自定义类型，当 TS 提供给你的基础类型都不满足的时候，可以使用 <code>type</code> 自由组合出你的新类型，而 <code>interface</code> 应该是对外输出的接口。</p>
<p><code>type</code> 不可以被继承，但 <code>interface</code> 可以：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> BaseApplication &#123;</span><br><span class="line">    appId: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Application <span class="keyword">extends</span> BaseApplication &#123;</span><br><span class="line">  init(): <span class="built_in">void</span></span><br><span class="line">    <span class="keyword">get</span>(key: <span class="built_in">string</span>): object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="declare"><a href="#declare" class="headerlink" title="declare"></a>declare</h2><p><code>declare</code> 可以创建 <code>*.d.ts</code> 文件中的变量，<code>declare</code> 只能作用域最外层：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> foo: <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">greeting: <span class="built_in">string</span></span>): <span class="title">void</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> tasaid &#123;</span><br><span class="line">  <span class="comment">// 这里不能 declare</span></span><br><span class="line">  <span class="keyword">interface</span> blog &#123;</span><br><span class="line">    website: <span class="string">'http://tasaid.com'</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本上顶层的定义都需要使用 <code>declare</code>， <code>class</code> 也是：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">class</span> User &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h2><p>为防止类型重复，使用 <code>namespace</code> 用于划分区域块，分离重复的类型，顶层的 <code>namespace</code> 需要 <code>declare</code> 输出到外部环境，子命名空间不需要 <code>declare</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命名空间</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> Models &#123;</span><br><span class="line">  <span class="keyword">type</span> A = <span class="built_in">number</span></span><br><span class="line">  <span class="comment">// 子命名空间</span></span><br><span class="line">  <span class="keyword">namespace</span> Config &#123;</span><br><span class="line">    <span class="keyword">type</span> A = object</span><br><span class="line">    <span class="keyword">type</span> B = <span class="built_in">string</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> C = Models.Config.A</span><br></pre></td></tr></table></figure>

<h2 id="组合定义"><a href="#组合定义" class="headerlink" title="组合定义"></a>组合定义</h2><p>上面我们只演示了一些简单的类型组合，生产环境中会包含许多复杂的类型定义，这时候我们就需要各种组合出强大的类型定义：</p>
<h3 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h3><p>有些类型的属性名是动态而未知的，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">'10086'</span>: &#123;</span><br><span class="line">    name: <span class="string">'中国移动'</span>,</span><br><span class="line">    website: <span class="string">'http://www.10086.cn'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'10010'</span>: &#123;</span><br><span class="line">    name: <span class="string">'中国联通'</span>,</span><br><span class="line">    website: <span class="string">'http://www.10010.com'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'10000'</span>: &#123;</span><br><span class="line">    name: <span class="string">'中国电信'</span>,</span><br><span class="line">    website: <span class="string">'http://www.189.cn'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以使用动态属性名来定义类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ChinaMobile &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  website: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ChinaMobileList &#123;</span><br><span class="line">  <span class="comment">// 动态属性</span></span><br><span class="line">  [phone: <span class="built_in">string</span>]: ChinaMobile</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型遍历"><a href="#类型遍历" class="headerlink" title="类型遍历"></a>类型遍历</h3><p>当你已知某个类型范围的时候，可以使用 <code>in</code> 和 <code>keyof</code> 来遍历类型，例如上面的 ChinaMobile 例子，我们可以使用 <code>in</code> 来约束属性名必须为三家运营商之一：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ChinaMobilePhones = <span class="string">'10086'</span> | <span class="string">'10010'</span> | <span class="string">'10000'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ChinaMobile &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  website: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能 type 使用， interface 无法使用</span></span><br><span class="line"><span class="keyword">type</span> ChinaMobileList = &#123;</span><br><span class="line">  <span class="comment">// 遍历属性</span></span><br><span class="line">  [phone <span class="keyword">in</span> ChinaMobilePhones]: ChinaMobile</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以用 <code>keyof</code> 来约定方法的参数</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> keys = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  appId: <span class="built_in">number</span>;</span><br><span class="line">  config: object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Application &#123;</span><br><span class="line">  <span class="comment">// 参数和值约束范围</span></span><br><span class="line">  <span class="keyword">set</span>&lt;T <span class="keyword">extends</span> keyof keys&gt;(key: T, val: keys[T])</span><br><span class="line">  <span class="keyword">get</span>&lt;T <span class="keyword">extends</span> keyof keys&gt;(key: T): keys[T]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog/.io//2094b0e190bf5c66045488f3c2cab5e5.png" alt="img"></p>
<h2 id="import-导入和-export-导出"><a href="#import-导入和-export-导出" class="headerlink" title="import 导入和 export 导出"></a>import 导入和 export 导出</h2><p>js 中有多种 <code>import</code> 和 <code>export</code>模块的方式，所以在 <code>d.ts</code> 中也对应有着不同的导入导出方式。</p>
<h3 id="导入规则"><a href="#导入规则" class="headerlink" title="导入规则"></a>导入规则</h3><p>在 ts 中不同的 <code>import</code> 语法会决定如何解析这个 module：</p>
<ul>
<li>有类型声明，标准 es module 库：<code>import * as xxxx from &#39;&#39;</code> 或 <code>import xxx from &#39;&#39;</code> 导入</li>
<li>有类型声明，标准 commonjs 库： <code>import xxx = require(&#39;&#39;)</code> 导入</li>
<li>没有类型声明：<code>const xxx = require(&#39;&#39;)</code> 导入（默认导入为 any 类型）</li>
</ul>
<p>同样，js 中不同的 <code>export</code> 语法也对应着不同的声明方式。</p>
<h3 id="export-default"><a href="#export-default" class="headerlink" title="export default"></a>export default</h3><p>如果 js 是 <code>es6 module</code> 风格的，通过 <code>export default</code> 导出的，经过编译工具编译为 <code>export.default</code> 以后(一般为 babel 或其他工具编译)，则声明文件这样写：</p>
<p>js 源文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line">exports.default = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>d.ts 声明文件：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出接口声明</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Options &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明默认函数</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span> (<span class="params">options: Options</span>): <span class="title">void</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 导出默认值</span></span><br><span class="line"><span class="function"><span class="title">export</span> <span class="title">default</span> <span class="title">main</span></span></span><br></pre></td></tr></table></figure>

<p>特点是这样引入(在 <code>tsconfig.json</code> 中没有开启 <code>allowSyntheticDefaultImports</code> 选项的情况下)：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入包</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> demo <span class="keyword">from</span> <span class="string">'demo'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Options &#125; <span class="keyword">from</span> <span class="string">'demo'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用默认方法</span></span><br><span class="line">demo(&#123; &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="module-exports"><a href="#module-exports" class="headerlink" title="module.exports"></a>module.exports</h3><p>如果 js 是 <code>commonjs</code> 风格的，是通过 <code>module.exports</code> 导出的，则声明文件这样写：</p>
<p>js 源文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>d.ts 声明文件：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包的声明</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span> (<span class="params">options: main.Options</span>): <span class="title">void</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 包里面的接口通过 <span class="title">namespace</span> 声明</span></span><br><span class="line"><span class="function"><span class="title">declare</span> <span class="title">namespace</span> <span class="title">main</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 导出接口声明</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> Options &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出包默认声明</span></span><br><span class="line"><span class="keyword">export</span> = main</span><br></pre></td></tr></table></figure>

<p>特点是这样引入：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入包</span></span><br><span class="line"><span class="keyword">import</span> demo = <span class="built_in">require</span>(<span class="string">'demo'</span>)</span><br><span class="line"><span class="comment">// 导入接口声明</span></span><br><span class="line"><span class="keyword">import</span> &#123; Options &#125; <span class="keyword">from</span> <span class="string">'demo'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用默认方法</span></span><br><span class="line">demo(&#123; &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="export-xxx"><a href="#export-xxx" class="headerlink" title="export xxx"></a>export xxx</h3><p>如果只是普通的 <code>exports xxx</code> ，经过编译工具编译为 <code>export.xxx</code> 之后，则声明文件相对简单：</p>
<p>js 源文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> func = <span class="function">(<span class="params">options</span>) =&gt;</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译为</span></span><br><span class="line">exports.func = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>d.ts 声明文件：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出接口声明</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Options &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">const</span> func: <span class="function">(<span class="params">options: Options</span>) =&gt;</span> <span class="built_in">void</span></span><br></pre></td></tr></table></figure>

<p>引入方式：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入接口声明</span></span><br><span class="line"><span class="keyword">import</span> &#123; Options, func &#125; <span class="keyword">from</span> <span class="string">'demo'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">func(&#123; &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="集成发布"><a href="#集成发布" class="headerlink" title="集成发布"></a>集成发布</h2><p>有两种主要方式用来发布类型定义文件到 <code>npm</code>：</p>
<ol>
<li>与你的 npm 包捆绑在一起(内置类型定义文件)</li>
<li>发布到 npm 上的 <a href="https://tasaid.com/link?url=https%3A%2F%2Fwww.npmjs.com%2F~types" target="_blank" rel="noopener">@types organization</a></li>
</ol>
<p>前者，安装完了包之后会自动检测并识别类型定义文件。 后者，则需要通过 <code>npm i @types/xxxx</code> 安装，这就是我们前面所说的 <a href="https://tasaid.com/link?url=https%3A%2F%2Fgithub.com%2FDefinitelyTyped%2FDefinitelyTyped" target="_blank" rel="noopener">DefinitelyTyped</a> ，用于扩展 JS 库的类型声明。</p>
<h3 id="内置类型定义文件"><a href="#内置类型定义文件" class="headerlink" title="内置类型定义文件"></a>内置类型定义文件</h3><p>内置类型定义就是把你的类型定义文件和 npm 包一起发布，一般来说，类型定义文件都放在包根目录的 <code>types</code> 目录里，例如 <a href="https://tasaid.com/link?url=https%3A%2F%2Fgithub.com%2Fvuejs%2Fvue%2Ftree%2Fv2.5.2%2Ftypes" target="_blank" rel="noopener">vue</a>：</p>
<p>如果你的包有一个主 <code>.js</code> 文件，需要在 <code>package.json</code> 里指定主类型定义文件。</p>
<p>设置 <code>types</code> 或 <code>typeings</code> 属性指向捆绑在一起的类型定义文件。 例如包目录如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">├── lib</span><br><span class="line">│   ├── main.js</span><br><span class="line">│   └── main.d.ts <span class="comment"># 类型定义文件</span></span><br><span class="line">└── package.json</span><br><span class="line">// pageage.json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"demo"</span>,</span><br><span class="line">    <span class="string">"author"</span>: <span class="string">"demo project"</span>,</span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">    <span class="string">"main"</span>: <span class="string">"./lib/main.js"</span>,</span><br><span class="line">    // 定义主类型定义文件</span><br><span class="line">    <span class="string">"types"</span>: <span class="string">"./lib/main.d.ts"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果主类型定义文件名是 <code>index.d.ts</code> 并且位置在包的根目录里，就不需要使用 <code>types</code> 属性指定了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── lib</span><br><span class="line">│   └── main.js</span><br><span class="line">├── index.d.ts <span class="comment"># 类型定义文件</span></span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure>

<p>如果你发的包中，<code>package.json</code> 中使用了 <code>files</code> 字段的话（<code>npm</code> 会根据 <code>files</code> 配置的规则决定发布哪些文件），则需要手动把类型定义文件加入：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pageage.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"files"</span>: [</span><br><span class="line">    <span class="string">"index.js"</span>,</span><br><span class="line">    <span class="string">"*.d.ts"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果只发二级目录的话，把类型定义文件放到对应的二级目录下即可：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> App &#125; <span class="keyword">from</span> <span class="string">'demo/app'</span></span><br></pre></td></tr></table></figure>

<h3 id="发布到-types-organizatio"><a href="#发布到-types-organizatio" class="headerlink" title="发布到 @types organizatio"></a>发布到 @types organizatio</h3><p>发布到 <code>@types organizatio</code> 的包表示源包没有包含类型定义文件，第三方/或原作者定义好类型定义文件之后，发布到 <a href="https://tasaid.com/link?url=https%3A%2F%2Fwww.npmjs.com%2F~types" target="_blank" rel="noopener">@types</a> 中。例如 <a href="https://tasaid.com/link?url=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2F%40types%2Fexpress" target="_blank" rel="noopener">@types/express</a>。</p>
<p>根据 <code>DefinitelyTyped</code> 的规则，和编辑器(和插件) 自动检测静态类型。</p>
<p><a href="https://tasaid.com/link?url=https%3A%2F%2Fwww.npmjs.com%2F~types" target="_blank" rel="noopener">@types</a> 下面的包是从 <a href="https://tasaid.com/link?url=https%3A%2F%2Fgithub.com%2FDefinitelyTyped%2FDefinitelyTyped" target="_blank" rel="noopener">DefinitelyTyped</a> 里自动发布的，通过 <a href="https://tasaid.com/link?url=https%3A%2F%2Fgithub.com%2FMicrosoft%2Ftypes-publisher" target="_blank" rel="noopener">types-publisher</a> 工具。</p>
<p>如果想让你的包发布为 @types 包，需要提交一个 pull request 到 <a href="https://tasaid.com/link?url=https%3A%2F%2Fgithub.com%2FDefinitelyTyped%2FDefinitelyTyped" target="_blank" rel="noopener">https://github.com/DefinitelyTyped/DefinitelyTyped</a>。</p>
<p>在这里查看详细信息 <a href="https://tasaid.com/link?url=http%3A%2F%2Fdefinitelytyped.org%2Fguides%2Fcontributing.html" target="_blank" rel="noopener">contribution guidelines page</a>。</p>
<p>如果你正在使用 TypeScript，而使用了一些 JS 包并没有对应的类型定义文件，可以编写一份然后提交到 <code>@types</code>。</p>
<p>赠人玫瑰，手留余香。</p>
<p>发布到 <code>@types organizatio</code> 的包可以通过 <a href="https://tasaid.com/link?url=https%3A%2F%2Fmicrosoft.github.io%2FTypeSearch%2F" target="_blank" rel="noopener">TypeSearch</a> 搜索检索，使用 <code>npm install --save-dev @types/xxxx</code> 安装：</p>
<p><img src="/blog/.io//26a7416bf2b8b2eebb74a32d2015eed3.png" alt="img"></p>
<p>更多细节请参阅 <a href="https://tasaid.com/link?url=https%3A%2F%2Fgithub.com%2FDefinitelyTyped%2FDefinitelyTyped" target="_blank" rel="noopener">DefinitelyTyped</a>。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="为第三方包声明类型"><a href="#为第三方包声明类型" class="headerlink" title="为第三方包声明类型"></a>为第三方包声明类型</h3><p>通常来说，如果这份类型定义文件是 JS 库自带的，那么我们可以直接导出模块：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> User &#123;&#125;</span><br><span class="line"><span class="keyword">export</span> = User</span><br></pre></td></tr></table></figure>

<p>而如果这份类型定义文件不是 JS 库自带的，而是第三方的，则需要使用 <code>module</code> 进行关联。</p>
<p>例如 <code>jquery</code> 发布的 npm 包中不包含 <code>*.d.ts</code> 类型定义文件，<code>jquery</code> 的类型定义文件发布在了 <code>@types/jquery</code>，所以类型定义文件中导出类型的时候，需要关联模块 <code>jquery</code>，意思就是我专门针对这个包做的类型定义：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> jQuery &#123;&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> 'jquery' &#123;</span><br><span class="line">    <span class="comment">// 因为 jquery 使用的是 commonjs module，所以需要用 export 导出</span></span><br><span class="line">    <span class="comment">// es6 module 可以使用 export default 导出</span></span><br><span class="line">    <span class="keyword">export</span> = jQuery;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从而解决了一些主流的 JS 库发布的 <code>npm</code> 包中没有类型定义文件，但是我们可以用第三方类型定义文件为这些库补充类型。</p>
<h3 id="风格"><a href="#风格" class="headerlink" title="风格"></a>风格</h3><p>经过一系列探索，个人比较推荐下面的编写风格，先看目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">types</span><br><span class="line">├── application.d.ts</span><br><span class="line">├── config.d.ts</span><br><span class="line">├── index.d.ts <span class="comment"># 入口模块</span></span><br><span class="line">└── user.d.ts</span><br></pre></td></tr></table></figure>

<p><img src="/blog/.io//b53c668059b6fc2f87dda190536d04f6.png" alt="img"></p>
<p>入口模块主要做这些事情：</p>
<ol>
<li>定义命名空间</li>
<li>导出和聚合子模块</li>
</ol>
<p>主出口文件 <code>index.d.ts</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> UserModel <span class="keyword">from</span> <span class="string">'./user'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> AppModel <span class="keyword">from</span> <span class="string">'./application'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ConfigModel <span class="keyword">from</span> <span class="string">'./config'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> Models &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">type</span> User = UserModel.User;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">type</span> Application = AppModel.Application;</span><br><span class="line">  <span class="comment">// 利用 as 抹平争议性变量名</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">type</span> Config = ConfigModel.Config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子模块无需定义命名空间，这样外部环境 (<code>types</code> 文件夹之外) 则无法获取子模块类型，达到了类型封闭的效果：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> User &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://supertinypeanut.github.io/blog/2020/02/17/type-definition/" data-id="ckmm8va72001v85qsc1872dch" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/TypeScript/" rel="tag">TypeScript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-vue-class-component" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/02/12/vue-class-component/" class="article-date">
  <time datetime="2020-02-12T10:10:10.000Z" itemprop="datePublished">2020-02-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/02/12/vue-class-component/">了解vue-class-component</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="vue-class-component"><a href="#vue-class-component" class="headerlink" title="vue-class-component"></a>vue-class-component</h1><p>本文翻译自 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fvuejs%2Fvue-class-component" target="_blank" rel="noopener">vue-class-component</a></p>
<blockquote>
<p>给 class 类型的 Vue 组件的 ECMAScript / TypeScript 修饰器</p>
</blockquote>
<h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><p>要求：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fwycats%2Fjavascript-decorators%2Fblob%2Fmaster%2FREADME.md" target="_blank" rel="noopener">ECMAScript 一阶段的修饰器</a>。<br> 如果你使用 Babel，需要使用 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Floganfsmyth%2Fbabel-plugin-transform-decorators-legacy" target="_blank" rel="noopener">babel-plugin-transform-decorators-legacy</a><br> 如果你使用 TypeScript，请启用 –experimentalDecorators 标识</p>
<blockquote>
<p>目前不支持二阶段修饰器，因为主流的编译器仍然编译旧版本的修饰器</p>
</blockquote>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>1.<code>methods</code> 可以直接声明作为 class 的方法</p>
<p>2.<code>computed</code> 可以直接声明作为 class 上属性的访问器</p>
<p>3.初始化的 <code>data</code> 可以声明作为 class 上的属性（如果你使用 Babel，你得使用<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fbabeljs.io%2Fdocs%2Fplugins%2Ftransform-class-properties%2F" target="_blank" rel="noopener">babel-plugin-transform-class-properties</a>）</p>
<p>4.<code>data</code>、<code>render</code> 以及 Vue 生命周期钩子也可以直接声明作为 class 上的方法，但是你不能够不能通过当前实例引用它们（？？？这句不懂），当你声明一个普通的方法，你也要避免使用这些保留字。</p>
<p>5.对于其它的选项（options），将它们传递给修饰器函数</p>
<p>以下是一个 Babel 下的例子，如果你需要 TypeScript 版本，请看<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fvuejs%2Fvue-class-component%2Fblob%2Fmaster%2Fexample%2Fsrc%2FApp.vue" target="_blank" rel="noopener">这里</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input v-model=<span class="string">"msg"</span>&gt;</span><br><span class="line">    &lt;p&gt;prop: &#123;&#123;propMessage&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;msg: &#123;&#123;msg&#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">    &lt;p&gt;helloMsg: &#123;&#123;helloMsg&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;computed msg: &#123;&#123;computedMsg&#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">    &lt;button @click=<span class="string">"greet"</span>&gt;Greet&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">import Vue from 'vue'</span></span><br><span class="line"><span class="regexp">import Component from 'vue-class-component'</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">@Component(&#123;</span></span><br><span class="line"><span class="regexp">  props: &#123;</span></span><br><span class="line"><span class="regexp">    propMessage: String</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp">export default class App extends Vue &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 初始化 data</span></span><br><span class="line"><span class="regexp">  msg = 123</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 使用 prop 数据初始化 data</span></span><br><span class="line"><span class="regexp">  helloMsg = 'Hello, ' + this.propMessage</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 生命周期</span></span><br><span class="line"><span class="regexp">  mounted () &#123;</span></span><br><span class="line"><span class="regexp">    this.greet()</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 计算属性 computed</span></span><br><span class="line"><span class="regexp">  get computedMsg () &#123;</span></span><br><span class="line"><span class="regexp">    return 'computed ' + this.msg</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ method</span></span><br><span class="line"><span class="regexp">  greet () &#123;</span></span><br><span class="line"><span class="regexp">    alert('greeting: ' + this.msg)</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<p>你可以在 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fkaorun343%2Fvue-property-decorator" target="_blank" rel="noopener">vue-property-decorator</a> 查看 <code>@prop</code>、<code>@watch</code> 修饰器</p>
<h3 id="使用-Mixins"><a href="#使用-Mixins" class="headerlink" title="使用 Mixins"></a>使用 Mixins</h3><p>vue-class-component 提供 mixins 帮助函数，可以用来在 class 类型风格中使用 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fvuejs.org%2Fv2%2Fguide%2Fmixins.html" target="_blank" rel="noopener">mixins</a><br> 通过 mixins 帮助函数，Typescript 可以推断出 mixin 类型并且在组件类型中继承它们。</p>
<p>声明 mixin 的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mixin.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">'vue-class-component'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 你可以想声明一个组件一样声明一个 mixin</span></span><br><span class="line">@Component</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMixin</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  mixinValue = <span class="string">'Hello'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后使用它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Component, &#123; mixins &#125; <span class="keyword">from</span> <span class="string">'vue-class-component'</span></span><br><span class="line"><span class="keyword">import</span> MyMixin <span class="keyword">from</span> <span class="string">'./mixin.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 `mixins` 帮助函数，而不是 `Vue`.</span></span><br><span class="line"><span class="comment">// `mixins` 可以获取任何数量的参数</span></span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComp</span> <span class="keyword">extends</span> <span class="title">mixins</span>(<span class="title">MyMixin</span>) </span>&#123;</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.mixinValue) <span class="comment">// -&gt; Hello</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义修饰器"><a href="#自定义修饰器" class="headerlink" title="自定义修饰器"></a>自定义修饰器</h3><p>你还可以创建你自己的修饰器并且继承这个库的功能，vue-class-component 提供 createDecorator 帮助函数用来创建自定义修饰器。</p>
<p>createDecorator 的第一个参数是一个回调函数，并且这个函数可以获取一下参数：</p>
<p><code>options</code>: vue 组件选项组成的对象，改变这些选项会影响所提供的组件<br> <code>key</code>: 修饰器所作为的属性或方法的 key<br> <code>parameterIndex</code>: 修饰器作用于参数时，这个参数的索引</p>
<p>例子：创建一个 NoCache 修饰器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// decorators.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createDecorator &#125; <span class="keyword">from</span> <span class="string">'vue-class-component'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NoCache = createDecorator(<span class="function">(<span class="params">options, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 组件的选项应该传给回调函数，同时会更新选项对象（options object）</span></span><br><span class="line">  <span class="comment">// 进而作用于组件</span></span><br><span class="line">  options.computed[key].cache = <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">import</span> &#123; NoCache &#125; <span class="keyword">from</span> <span class="string">'./decorators'</span></span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComp</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这个计算属性不会被缓存</span></span><br><span class="line">  @NoCache</span><br><span class="line">  <span class="keyword">get</span> random () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.random()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加自定义钩子"><a href="#添加自定义钩子" class="headerlink" title="添加自定义钩子"></a>添加自定义钩子</h3><p>如果你使用了一些Vue 插件比如 Vue Router，你可能会希望 class 组件解析它们所提供的钩子，比如，下面的例子中 <code>Component.registerHooks</code> 就允许你注册这些钩子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class-component-hooks.js</span></span><br><span class="line"><span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">'vue-class-component'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过这些钩子的名称来注册它们</span></span><br><span class="line">Component.registerHooks([</span><br><span class="line">  <span class="string">'beforeRouteEnter'</span>,</span><br><span class="line">  <span class="string">'beforeRouteLeave'</span>,</span><br><span class="line">  <span class="string">'beforeRouteUpdate'</span> <span class="comment">// for vue-router 2.2+</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyComp.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">'vue-class-component'</span></span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComp</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  <span class="comment">// class 组件现在可以处理 beforeRouteEnter 钩子和 </span></span><br><span class="line">  <span class="comment">// beforeRouteLeave 钩子作为 Vue Router 钩子</span></span><br><span class="line">  beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'beforeRouteEnter'</span>)</span><br><span class="line">    next() <span class="comment">// 需要调用这个来确认导航</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'beforeRouteLeave'</span>)</span><br><span class="line">    next() <span class="comment">// 需要调用这个来确认导航</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，你必须在组件定义之前注册钩子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保在引入任何组件之前注册</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./class-component-hooks'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> MyComp <span class="keyword">from</span> <span class="string">'./MyComp'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    MyComp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>vue-class-component 通过实例化 钩子下的初始构造函数来收集 class 属性作为 Vue 实例的 data（？？？这句不太懂）。然而我们也可以像本地 class 的方式定义实例 data，有时候我们需要知道它是如何工作的。</p>
<h5 id="this"><a href="#this" class="headerlink" title="this"></a>this</h5><p>如果你定义一个 class 属性并且在里面访问 this，它不会起作用，因为 this 只是当我们实例化 class 属性时候 Vue 实例的一个拦截对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComp</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  foo = <span class="number">123</span></span><br><span class="line"></span><br><span class="line">  bar = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 不会如预期中的更新</span></span><br><span class="line">    <span class="comment">// `this` 的值实际上不是 Vue 实例</span></span><br><span class="line">    <span class="keyword">this</span>.foo = <span class="number">456</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以简单地定义一个方法而不是一个 class 属性因为 Vue 会自动绑定实例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComp</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  foo = <span class="number">123</span></span><br><span class="line"></span><br><span class="line">  bar () &#123;</span><br><span class="line">    <span class="comment">// 如预期地更新数据</span></span><br><span class="line">    <span class="keyword">this</span>.foo = <span class="number">456</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="undefined-不会响应式"><a href="#undefined-不会响应式" class="headerlink" title="undefined 不会响应式"></a>undefined 不会响应式</h5><p>为了在 Babel 和 TypeScript 上表现稳定，如果一个属性的初始化值是 undefined，vue-class-components 不会对它触发响应式，你应该使用 null 作为 初始值货值使用 data 钩子来初始化值为 undefined 的属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComp</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 没有响应式</span></span><br><span class="line">  foo = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 响应式</span></span><br><span class="line">  bar = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 响应式</span></span><br><span class="line">      baz: <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="创建例子"><a href="#创建例子" class="headerlink" title="创建例子"></a>创建例子</h5><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install &amp;&amp; npm run example</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://supertinypeanut.github.io/blog/2020/02/12/vue-class-component/" data-id="ckmm8va5m000u85qs7tm58agy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Vue/" rel="tag">Vue</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-vueInterView" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/02/12/vueInterView/" class="article-date">
  <time datetime="2020-02-12T10:10:10.000Z" itemprop="datePublished">2020-02-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/02/12/vueInterView/">Vue 面试题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1、说说你对-SPA-单页面的理解，它的优缺点分别是什么？"><a href="#1、说说你对-SPA-单页面的理解，它的优缺点分别是什么？" class="headerlink" title="1、说说你对 SPA 单页面的理解，它的优缺点分别是什么？"></a>1、说说你对 SPA 单页面的理解，它的优缺点分别是什么？</h2><p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p>
<p><strong>优点：</strong></p>
<ul>
<li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li>
<li>基于上面一点，SPA 相对对服务器压力小；</li>
<li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li>
<li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li>
<li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li>
</ul>
<h2 id="2、v-show-与-v-if-有什么区别？"><a href="#2、v-show-与-v-if-有什么区别？" class="headerlink" title="2、v-show 与 v-if 有什么区别？"></a>2、v-show 与 v-if 有什么区别？</h2><p><strong>v-if</strong> 是<strong>真正</strong>的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>
<p><strong>v-show</strong> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。</p>
<p>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p>
<h2 id="3、Class-与-Style-如何动态绑定？"><a href="#3、Class-与-Style-如何动态绑定？" class="headerlink" title="3、Class 与 Style 如何动态绑定？"></a>3、Class 与 Style 如何动态绑定？</h2><p>Class 可以通过对象语法和数组语法进行动态绑定：</p>
<ul>
<li>对象语法：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"&#123; active: isActive, 'text-danger': hasError &#125;"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">data: &#123;</span></span><br><span class="line"><span class="regexp">  isActive: true,</span></span><br><span class="line"><span class="regexp">  hasError: false</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>数组语法：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"[isActive ? activeClass : '', errorClass]"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">data: &#123;</span></span><br><span class="line"><span class="regexp">  activeClass: 'active',</span></span><br><span class="line"><span class="regexp">  errorClass: 'text-danger'</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>Style 也可以通过对象语法和数组语法进行动态绑定：</p>
<ul>
<li>对象语法：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=<span class="string">"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">data: &#123;</span></span><br><span class="line"><span class="regexp">  activeColor: 'red',</span></span><br><span class="line"><span class="regexp">  fontSize: 30</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>数组语法：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=<span class="string">"[styleColor, styleSize]"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">data: &#123;</span></span><br><span class="line"><span class="regexp">  styleColor: &#123;</span></span><br><span class="line"><span class="regexp">     color: 'red'</span></span><br><span class="line"><span class="regexp">   &#125;,</span></span><br><span class="line"><span class="regexp">  styleSize:&#123;</span></span><br><span class="line"><span class="regexp">     fontSize:'23px'</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="4、怎样理解-Vue-的单向数据流？"><a href="#4、怎样理解-Vue-的单向数据流？" class="headerlink" title="4、怎样理解 Vue 的单向数据流？"></a>4、怎样理解 Vue 的单向数据流？</h2><p>所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。</p>
<p>这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p>
<p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。</p>
<p>这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。</p>
<p>子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p>
<p>有两种常见的试图改变一个 prop 的情形 :</p>
<ul>
<li><strong>这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。</strong> 在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">'initialCounter'</span>],</span><br><span class="line">data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    counter: <span class="keyword">this</span>.initialCounter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>这个 prop 以一种原始的值传入且需要进行转换**</strong>。** 在这种情况下，最好使用这个 prop 的值来定义一个计算属性</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">'size'</span>],</span><br><span class="line">computed: &#123;</span><br><span class="line">  normalizedSize: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size.trim().toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、computed-和-watch-的区别和运用的场景？"><a href="#5、computed-和-watch-的区别和运用的场景？" class="headerlink" title="5、computed 和 watch 的区别和运用的场景？"></a>5、computed 和 watch 的区别和运用的场景？</h2><p><strong>computed：</strong> 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；</p>
<p><strong>watch：</strong> 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p>
<p><strong>运用场景：</strong></p>
<ul>
<li>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</li>
<li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li>
</ul>
<h2 id="6、直接给一个数组项赋值，Vue-能检测到变化吗？"><a href="#6、直接给一个数组项赋值，Vue-能检测到变化吗？" class="headerlink" title="6、直接给一个数组项赋值，Vue 能检测到变化吗？"></a>6、直接给一个数组项赋值，Vue 能检测到变化吗？</h2><p>由于 JavaScript 的限制，Vue 不能检测到以下数组的变动：</p>
<ul>
<li>当你利用索引直接设置一个数组项时，例如：<code>vm.items[indexOfItem] = newValue</code></li>
<li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li>
</ul>
<p>为了解决第一个问题，Vue 提供了以下操作方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue.set</span></span><br><span class="line">Vue.set(vm.items, indexOfItem, newValue)</span><br><span class="line"><span class="comment">// vm.$set，Vue.set的一个别名</span></span><br><span class="line">vm.$<span class="keyword">set</span>(vm.items, indexOfItem, newValue)</span><br><span class="line">// Array.prototype.splice</span><br><span class="line">vm.items.splice(indexOfItem, 1, newValue)</span><br></pre></td></tr></table></figure>

<p>为了解决第二个问题，Vue 提供了以下操作方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array.prototype.splice</span></span><br><span class="line">vm.items.splice(newLength)</span><br></pre></td></tr></table></figure>

<h2 id="7、谈谈你对-Vue-生命周期的理解？"><a href="#7、谈谈你对-Vue-生命周期的理解？" class="headerlink" title="7、谈谈你对 Vue 生命周期的理解？"></a>7、谈谈你对 Vue 生命周期的理解？</h2><p><strong>（1）生命周期是什么？</strong></p>
<p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p>
<p><strong>（2）各个生命周期的作用</strong></p>
<table>
<thead>
<tr>
<th>生命周期</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>beforeCreate</td>
<td>组件实例被创建之初，组件的属性生效之前</td>
</tr>
<tr>
<td>created</td>
<td>组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用</td>
</tr>
<tr>
<td>beforeMount</td>
<td>在挂载开始之前被调用：相关的 render 函数首次被调用</td>
</tr>
<tr>
<td>mounted</td>
<td>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</td>
</tr>
<tr>
<td>beforeUpdate</td>
<td>组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</td>
</tr>
<tr>
<td>update</td>
<td>组件数据更新之后</td>
</tr>
<tr>
<td>activited</td>
<td>keep-alive 专属，组件被激活时调用</td>
</tr>
<tr>
<td>deadctivated</td>
<td>keep-alive 专属，组件被销毁时调用</td>
</tr>
<tr>
<td>beforeDestory</td>
<td>组件销毁前调用</td>
</tr>
<tr>
<td>destoryed</td>
<td>组件销毁后调用</td>
</tr>
</tbody></table>
<p><strong>（3）生命周期示意图</strong></p>
<p><img src="/blog/.io//640.jpeg" alt="img"></p>
<p><strong>8、Vue 的父组件和子组件生命周期钩子函数执行顺序？</strong></p>
<p>Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：</p>
<ul>
<li>加载渲染过程</li>
</ul>
<p>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p>
<ul>
<li>子组件更新过程</li>
</ul>
<p>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p>
<ul>
<li>父组件更新过程</li>
</ul>
<p>父 beforeUpdate -&gt; 父 updated</p>
<ul>
<li>销毁过程</li>
</ul>
<p>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p>
<h2 id="9、在哪个生命周期内调用异步请求？"><a href="#9、在哪个生命周期内调用异步请求？" class="headerlink" title="9、在哪个生命周期内调用异步请求？"></a>9、在哪个生命周期内调用异步请求？</h2><p>可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p>
<ul>
<li>能更快获取到服务端数据，减少页面 loading 时间；</li>
<li>ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</li>
</ul>
<h2 id="10、在什么阶段才能访问操作DOM？"><a href="#10、在什么阶段才能访问操作DOM？" class="headerlink" title="10、在什么阶段才能访问操作DOM？"></a>10、在什么阶段才能访问操作DOM？</h2><p>在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以在 mounted 中可以访问操作 DOM。</p>
<p>vue 具体的生命周期示意图可以参见如下，理解了整个生命周期各个阶段的操作，关于生命周期相关的面试题就难不倒你了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/eXCSRjyNYcblWUNqyAuzIIuDK6xB4Q0Tj07ibDMZ0D6o9XxFrKHoZBb7Xicprx01TkI6s68xuCxTBSxiaqMPnPocg/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h2 id="11、父组件可以监听到子组件的生命周期吗？"><a href="#11、父组件可以监听到子组件的生命周期吗？" class="headerlink" title="11、父组件可以监听到子组件的生命周期吗？"></a>11、父组件可以监听到子组件的生命周期吗？</h2><p>比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parent.vue</span></span><br><span class="line">&lt;Child @mounted=<span class="string">"doSomething"</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Child.vue</span></span><br><span class="line">mounted() &#123;</span><br><span class="line">  <span class="keyword">this</span>.$emit(<span class="string">"mounted"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Parent.vue</span></span><br><span class="line">&lt;Child @hook:mounted=<span class="string">"doSomething"</span> &gt;&lt;<span class="regexp">/Child&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">doSomething() &#123;</span></span><br><span class="line"><span class="regexp">   console.log('父组件监听到 mounted 钩子函数 ...');</span></span><br><span class="line"><span class="regexp">&#125;,</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/  Child.vue</span></span><br><span class="line"><span class="regexp">mounted()&#123;</span></span><br><span class="line"><span class="regexp">   console.log('子组件触发 mounted 钩子函数 ...');</span></span><br><span class="line"><span class="regexp">&#125;,    </span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 以上输出顺序为：</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 子组件触发 mounted 钩子函数 ...</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 父组件监听到 mounted 钩子函数 ...</span></span><br></pre></td></tr></table></figure>

<p>当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。</p>
<h2 id="12、谈谈你对-keep-alive-的了解？"><a href="#12、谈谈你对-keep-alive-的了解？" class="headerlink" title="12、谈谈你对 keep-alive 的了解？"></a>12、谈谈你对 keep-alive 的了解？</h2><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</p>
<ul>
<li>一般结合路由和动态组件一起使用，用于缓存组件；</li>
<li>提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；</li>
<li>对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</li>
</ul>
<h2 id="13、组件中-data-为什么是一个函数？"><a href="#13、组件中-data-为什么是一个函数？" class="headerlink" title="13、组件中 data 为什么是一个函数？"></a>13、组件中 data 为什么是一个函数？</h2><blockquote>
<p>为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// data</span></span><br><span class="line">data() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    message: <span class="string">"子组件"</span>,</span><br><span class="line">    childName:<span class="keyword">this</span>.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new Vue</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span>,</span><br><span class="line">  components: &#123;App&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，</p>
<p>如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。</p>
<h2 id="14、v-model-的原理？"><a href="#14、v-model-的原理？" class="headerlink" title="14、v-model 的原理？"></a>14、v-model 的原理？</h2><p>我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p>
<ul>
<li>text 和 textarea 元素使用 value 属性和 input 事件；</li>
<li>checkbox 和 radio 使用 checked 属性和 change 事件；</li>
<li>select 字段将 value 作为 prop 并将 change 作为事件。</li>
</ul>
<p>以 input 表单元素为例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">'something'</span>&gt;</span><br><span class="line"></span><br><span class="line">相当于</span><br><span class="line"></span><br><span class="line">&lt;input v-bind:value=<span class="string">"something"</span> v-on:input=<span class="string">"something = $event.target.value"</span>&gt;</span><br></pre></td></tr></table></figure>

<p>如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">父组件：</span><br><span class="line">&lt;ModelChild v-model=<span class="string">"message"</span>&gt;&lt;<span class="regexp">/ModelChild&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">子组件：</span></span><br><span class="line"><span class="regexp">&lt;div&gt;&#123;&#123;value&#125;&#125;&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">props:&#123;</span><br><span class="line">    value: <span class="built_in">String</span></span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  test1()&#123;</span><br><span class="line">     <span class="keyword">this</span>.$emit(<span class="string">'input'</span>, <span class="string">'小红'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="15、Vue-组件间通信有哪几种方式？"><a href="#15、Vue-组件间通信有哪几种方式？" class="headerlink" title="15、Vue 组件间通信有哪几种方式？"></a>15、Vue 组件间通信有哪几种方式？</h2><p>Vue 组件间通信是面试常考的知识点之一，这题有点类似于开放题，你回答出越多方法当然越加分，表明你对 Vue 掌握的越熟练。</p>
<p>Vue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信。</p>
<p><strong>（1）<code>props / $emit</code> 适用 父子组件通信</strong></p>
<p>这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。</p>
<p><strong>（2）<code>ref</code> 与 <code>$parent / $children</code> 适用 父子组件通信</strong></p>
<ul>
<li><code>ref</code>：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例</li>
<li><code>$parent</code> / <code>$children</code>：访问父 / 子实例</li>
</ul>
<p><strong>（3）<code>EventBus （$emit / $on）</code> 适用于 父子、隔代、兄弟组件通信</strong></p>
<p>这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。</p>
<p><strong>（4）<code>$attrs</code>/<code>$listeners</code> 适用于 隔代组件通信</strong></p>
<ul>
<li><code>$attrs</code>：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 <code>v-bind=&quot;$attrs&quot;</code> 传入内部组件。通常配合 inheritAttrs 选项一起使用。</li>
<li><code>$listeners</code>：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 <code>v-on=&quot;$listeners&quot;</code> 传入内部组件</li>
</ul>
<p><strong>（5）<code>provide / inject</code> 适用于 隔代组件通信</strong></p>
<p>祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。</p>
<p><strong>（6）Vuex 适用于 父子、隔代、兄弟组件通信</strong></p>
<p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p>
<ul>
<li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>
<li>改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</li>
</ul>
<h2 id="16、你使用过-Vuex-吗？"><a href="#16、你使用过-Vuex-吗？" class="headerlink" title="16、你使用过 Vuex 吗？"></a>16、你使用过 Vuex 吗？</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p>
<p>（1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p>
<p>（2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</p>
<p>主要包括以下几个模块：</p>
<ul>
<li>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。</li>
<li>Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li>
<li>Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。</li>
<li>Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。</li>
<li>Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</li>
</ul>
<h2 id="17、使用过-Vue-SSR-吗？说说-SSR？"><a href="#17、使用过-Vue-SSR-吗？说说-SSR？" class="headerlink" title="17、使用过 Vue SSR 吗？说说 SSR？"></a>17、使用过 Vue SSR 吗？说说 SSR？</h2><blockquote>
<p>Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。</p>
<p>即：SSR大致的意思就是vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。</p>
</blockquote>
<p><strong>服务端渲染 SSR 的优缺点如下：</strong></p>
<p><strong>（1）服务端渲染的优点：</strong></p>
<ul>
<li>更好的 SEO：因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；</li>
<li>更快的内容到达时间（首屏加载更快）：SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；</li>
</ul>
<p><strong>（2) 服务端渲染的缺点：</strong></p>
<ul>
<li>更多的开发条件限制：例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；</li>
<li>更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。</li>
</ul>
<h2 id="18、vue-router-路由模式有几种？"><a href="#18、vue-router-路由模式有几种？" class="headerlink" title="18、vue-router 路由模式有几种？"></a>18、vue-router 路由模式有几种？</h2><p>vue-router 有 3 种路由模式：hash、history、abstract，对应的源码如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'history'</span>:</span><br><span class="line">    <span class="keyword">this</span>.history = <span class="keyword">new</span> HTML5History(<span class="keyword">this</span>, options.base)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">'hash'</span>:</span><br><span class="line">    <span class="keyword">this</span>.history = <span class="keyword">new</span> HashHistory(<span class="keyword">this</span>, options.base, <span class="keyword">this</span>.fallback)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">'abstract'</span>:</span><br><span class="line">    <span class="keyword">this</span>.history = <span class="keyword">new</span> AbstractHistory(<span class="keyword">this</span>, options.base)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      assert(<span class="literal">false</span>, <span class="string">`invalid mode: <span class="subst">$&#123;mode&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，3 种路由模式的说明如下：</p>
<ul>
<li>hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；</li>
<li>history : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；</li>
<li>abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</li>
</ul>
<h2 id="19、能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？"><a href="#19、能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？" class="headerlink" title="19、能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？"></a>19、能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？</h2><p><strong>（1）hash 模式的实现原理</strong></p>
<p>早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 ‘#search’：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//www.word.com#search</span></span><br></pre></td></tr></table></figure>

<p>hash 路由模式的实现主要是基于下面几个特性：</p>
<ul>
<li>URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；</li>
<li>hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；</li>
<li>可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；</li>
<li>我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。</li>
</ul>
<p><strong>（2）history 模式的实现原理</strong></p>
<p>HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。</p>
<p>唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, path);</span><br><span class="line"><span class="built_in">window</span>.history.replaceState(<span class="literal">null</span>, <span class="literal">null</span>, path);</span><br></pre></td></tr></table></figure>

<p>history 路由模式的实现主要基于存在下面几个特性：</p>
<ul>
<li>pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；</li>
<li>我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）；</li>
<li>history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。</li>
</ul>
<h2 id="20、什么是-MVVM？"><a href="#20、什么是-MVVM？" class="headerlink" title="20、什么是 MVVM？"></a>20、什么是 MVVM？</h2><p>Model–View–ViewModel （MVVM） 是一个软件架构设计模式，由微软 WPF 和 Silverlight 的架构师 Ken Cooper 和 Ted Peters 开发，是一种简化用户界面的事件驱动编程方式。</p>
<p>由 John Gossman（同样也是 WPF 和 Silverlight 的架构师）于2005年在他的博客上发表</p>
<p>MVVM 源自于经典的 Model–View–Controller（MVC）模式 ，MVVM 的出现促进了前端开发与后端业务逻辑的分离，极大地提高了前端开发效率，MVVM 的核心是 ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。</p>
<p>如下图所示：</p>
<p><img src="/blog/.io//640-20200212012544052.jpeg" alt="img"></p>
<p><strong>（1）View 层</strong></p>
<p>View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。</p>
<p><strong>（2）Model 层</strong></p>
<p>Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。</p>
<p><strong>（3）ViewModel 层</strong></p>
<p>ViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。</p>
<p>需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的，比如页面的这一块展示什么，而页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互），视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层。</p>
<p>MVVM 框架实现了双向绑定，这样 ViewModel 的内容会实时展现在 View 层，前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图，MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新。</p>
<p>这样 View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。</p>
<p>我们以下通过一个 Vue 实例来说明 MVVM 的具体实现，有 Vue 开发经验的同学应该一目了然：</p>
<p>（1）View 层</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button v-on:click="showMessage()"&gt;Click me&lt;/</span>button&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）ViewModel 层</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;  <span class="comment">// 用于描述视图状态</span></span><br><span class="line">        message: <span class="string">'Hello Vue!'</span>, </span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;  <span class="comment">// 用于描述视图行为</span></span><br><span class="line">        showMessage()&#123;</span><br><span class="line">            <span class="keyword">let</span> vm = <span class="keyword">this</span>;</span><br><span class="line">            alert(vm.message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created()&#123;</span><br><span class="line">        <span class="keyword">let</span> vm = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// Ajax 获取 Model 层的数据</span></span><br><span class="line">        ajax(&#123;</span><br><span class="line">            url: <span class="string">'/your/server/data/api'</span>,</span><br><span class="line">            success(res)&#123;</span><br><span class="line">                vm.message = res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>（3） Model 层</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"url"</span>: <span class="string">"/your/server/data/api"</span>,</span><br><span class="line">    <span class="attr">"res"</span>: &#123;</span><br><span class="line">        <span class="attr">"success"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"IoveC"</span>,</span><br><span class="line">        <span class="attr">"domain"</span>: <span class="string">"www.cnblogs.com"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="21、Vue-是如何实现数据双向绑定的？"><a href="#21、Vue-是如何实现数据双向绑定的？" class="headerlink" title="21、Vue 是如何实现数据双向绑定的？"></a>21、Vue 是如何实现数据双向绑定的？</h2><p>Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据，如下图所示：</p>
<p><img src="/blog/.io//640-20200212012544079.jpeg" alt="img"></p>
<p>即：</p>
<ul>
<li>输入框内容变化时，Data 中的数据同步变化。即 View =&gt; Data 的变化。</li>
<li>Data 中的数据变化时，文本节点的内容同步变化。即 Data =&gt; View 的变化。</li>
</ul>
<p>其中，View 变化更新 Data ，可以通过事件监听的方式来实现，所以 Vue 的数据双向绑定的工作主要是如何根据 Data 变化更新 View。</p>
<p>Vue 主要通过以下 4 个步骤来实现数据双向绑定的：</p>
<p>实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。</p>
<p>实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。</p>
<p>实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。</p>
<p>实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。</p>
<p>以上四个步骤的流程图表示如下，如果有同学理解不大清晰的，可以查看作者专门介绍数据双向绑定的文章《0 到 1 掌握：Vue 核心之数据双向绑定》，有进行详细的讲解、以及代码 demo 示例。</p>
<p><img src="/blog/.io//640-20200212012544051.jpeg" alt="img"></p>
<h2 id="22、Vue-框架怎么实现对象和数组的监听？"><a href="#22、Vue-框架怎么实现对象和数组的监听？" class="headerlink" title="22、Vue 框架怎么实现对象和数组的监听？"></a>22、Vue 框架怎么实现对象和数组的监听？</h2><p>如果被问到 Vue 怎么实现数据双向绑定，大家肯定都会回答 通过 Object.defineProperty() 对数据进行劫持，但是 Object.defineProperty() 只能对属性进行数据劫持，不能对整个对象进行劫持。</p>
<p>同理无法对数组进行劫持，但是我们在使用 Vue 框架中都知道，Vue 能检测到对象和数组（部分方法的操作）的变化，那它是怎么实现的呢？我们查看相关代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Observe a list of Array items.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">    observe(items[i])  <span class="comment">// observe 功能为监测数据的变化</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对属性进行递归遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val) <span class="comment">// observe 功能为监测数据的变化</span></span><br></pre></td></tr></table></figure>

<p>通过以上 Vue 源码部分查看，我们就能知道 Vue 框架是通过遍历数组 和递归遍历对象，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。</p>
<h2 id="23、Proxy-与-Object-defineProperty-优劣对比"><a href="#23、Proxy-与-Object-defineProperty-优劣对比" class="headerlink" title="23、Proxy 与 Object.defineProperty 优劣对比"></a>23、Proxy 与 Object.defineProperty 优劣对比</h2><p><strong>Proxy 的优势如下:</strong></p>
<ul>
<li>Proxy 可以直接监听对象而非属性；</li>
<li>Proxy 可以直接监听数组的变化；</li>
<li>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；</li>
<li>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；</li>
<li>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；</li>
</ul>
<p><strong>Object.defineProperty 的优势如下:</strong></p>
<ul>
<li>兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。</li>
</ul>
<h2 id="24、Vue-怎么用-vm-set-解决对象新增属性不能响应的问题-？"><a href="#24、Vue-怎么用-vm-set-解决对象新增属性不能响应的问题-？" class="headerlink" title="24、Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？"></a>24、Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？</h2><p>受现代 JavaScript 的限制 ，Vue <strong>无法检测到对象属性的添加或删除</strong>。</p>
<p>由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。</p>
<p>但是 Vue 提供了 <code>Vue.set (object, propertyName, value) / vm.$set (object, propertyName, value)</code>来实现为对象添加响应式属性，那框架本身是如何实现的呢？</p>
<p>我们查看对应的 Vue 源码：<code>vue/src/core/instance/index.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span> (<span class="params">target: Array&lt;any&gt; | Object, key: any, val: any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="comment">// target 为数组</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    <span class="comment">// 修改数组的长度, 避免索引&gt;数组长度导致splcie()执行有误</span></span><br><span class="line">    target.length = <span class="built_in">Math</span>.max(target.length, key)</span><br><span class="line">    <span class="comment">// 利用数组的splice变异方法触发响应式</span></span><br><span class="line">    target.splice(key, <span class="number">1</span>, val)</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// key 已经存在，直接修改属性值</span></span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">in</span> target &amp;&amp; !(key <span class="keyword">in</span> <span class="built_in">Object</span>.prototype)) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> ob = (target: any).__ob__</span><br><span class="line">  <span class="comment">// target 本身就不是响应式数据, 直接赋值</span></span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对属性进行响应式处理</span></span><br><span class="line">  defineReactive(ob.value, key, val)</span><br><span class="line">  ob.dep.notify()</span><br><span class="line">  <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们阅读以上源码可知，vm.$set 的实现原理是：</p>
<ul>
<li>如果目标是数组，直接使用数组的 splice 方法触发相应式；</li>
<li>如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）</li>
</ul>
<h2 id="25、虚拟-DOM-的优缺点？"><a href="#25、虚拟-DOM-的优缺点？" class="headerlink" title="25、虚拟 DOM 的优缺点？"></a>25、虚拟 DOM 的优缺点？</h2><p><strong>优点：</strong></p>
<ul>
<li><strong>保证性能下限：</strong> 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</li>
<li><strong>无需手动操作 DOM：</strong> 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</li>
<li><strong>跨平台：</strong> 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。</li>
</ul>
<p><strong>缺点:</strong></p>
<ul>
<li><strong>无法进行极致优化：</strong> 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。</li>
</ul>
<h2 id="26、虚拟-DOM-实现原理？"><a href="#26、虚拟-DOM-实现原理？" class="headerlink" title="26、虚拟 DOM 实现原理？"></a>26、虚拟 DOM 实现原理？</h2><p>虚拟 DOM 的实现原理主要包括以下 3 部分：</p>
<ul>
<li>用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；</li>
<li>diff 算法 — 比较两棵虚拟 DOM 树的差异；</li>
<li>pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。</li>
</ul>
<h2 id="27、Vue-中的-key-有什么作用？"><a href="#27、Vue-中的-key-有什么作用？" class="headerlink" title="27、Vue 中的 key 有什么作用？"></a>27、Vue 中的 key 有什么作用？</h2><p>key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。</p>
<p>Vue 的 diff 过程可以概括为：oldCh 和 newCh 各有两个头尾的变量 oldStartIndex、oldEndIndex 和 newStartIndex、newEndIndex，它们会新节点和旧节点会进行两两对比，即一共有4种比较方式：newStartIndex 和oldStartIndex 、newEndIndex 和 oldEndIndex 、newStartIndex 和 oldEndIndex 、newEndIndex 和 oldStartIndex，如果以上 4 种比较都没匹配，如果设置了key，就会用 key 再进行比较，在比较的过程中，遍历会往中间靠，一旦 StartIdx &gt; EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较。</p>
<p>具体有无 key 的 diff 过程，可以查看作者写的另一篇详解虚拟 DOM 的文章《深入剖析：Vue核心之虚拟DOM》</p>
<p>所以 Vue 中 key 的作用是：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速</p>
<p><strong>更准确</strong>：因为带 key 就不是就地复用了，在 sameNode 函数 <code>a.key === b.key</code> 对比中可以避免就地复用的情况。所以会更加准确。</p>
<p><strong>更快速</strong>：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快，源码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createKeyToOldIdx</span> (<span class="params">children, beginIdx, endIdx</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i, key</span><br><span class="line">  <span class="keyword">const</span> map = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (i = beginIdx; i &lt;= endIdx; ++i) &#123;</span><br><span class="line">    key = children[i].key</span><br><span class="line">    <span class="keyword">if</span> (isDef(key)) map[key] = i</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="28、你有对-Vue-项目进行哪些优化？"><a href="#28、你有对-Vue-项目进行哪些优化？" class="headerlink" title="28、你有对 Vue 项目进行哪些优化？"></a>28、你有对 Vue 项目进行哪些优化？</h2><p>如果没有对 Vue 项目没有进行过优化总结的同学，可以参考本文作者的另一篇文章《 Vue 项目性能优化 — 实践指南 》，文章主要介绍从 3 个大方面，22 个小方面详细讲解如何进行 Vue 项目的优化。</p>
<p><strong>（1）代码层面的优化</strong></p>
<ul>
<li>v-if 和 v-show 区分使用场景</li>
<li>computed 和 watch 区分使用场景</li>
<li>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</li>
<li>长列表性能优化</li>
<li>事件的销毁</li>
<li>图片资源懒加载</li>
<li>路由懒加载</li>
<li>第三方插件的按需引入</li>
<li>优化无限列表性能</li>
<li>服务端渲染 SSR or 预渲染</li>
</ul>
<p><strong>（2）Webpack 层面的优化</strong></p>
<ul>
<li>Webpack 对图片进行压缩</li>
<li>减少 ES6 转为 ES5 的冗余代码</li>
<li>提取公共代码</li>
<li>模板预编译</li>
<li>提取组件的 CSS</li>
<li>优化 SourceMap</li>
<li>构建结果输出分析</li>
<li>Vue 项目的编译优化</li>
</ul>
<p><strong>（3）基础的 Web 技术的优化</strong></p>
<ul>
<li>开启 gzip 压缩</li>
<li>浏览器缓存</li>
<li>CDN 的使用</li>
<li>使用 Chrome Performance 查找性能瓶颈</li>
</ul>
<h2 id="29、对于即将到来的-vue3-0-特性你有什么了解的吗？"><a href="#29、对于即将到来的-vue3-0-特性你有什么了解的吗？" class="headerlink" title="29、对于即将到来的 vue3.0 特性你有什么了解的吗？"></a>29、对于即将到来的 vue3.0 特性你有什么了解的吗？</h2><p>Vue 3.0 正走在发布的路上，Vue 3.0 的目标是让 Vue 核心变得更小、更快、更强大，因此 Vue 3.0 增加以下这些新特性：</p>
<p><strong>（1）监测机制的改变</strong></p>
<p>3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的反应性跟踪。这消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：</p>
<ul>
<li>只能监测属性，不能监测对象</li>
<li>检测属性的添加和删除；</li>
<li>检测数组索引和长度的变更；</li>
<li>支持 Map、Set、WeakMap 和 WeakSet。</li>
</ul>
<p>新的 observer 还提供了以下特性：</p>
<ul>
<li>用于创建 observable 的公开 API。这为中小规模场景提供了简单轻量级的跨组件状态管理解决方案。</li>
<li>默认采用惰性观察。在 2.x 中，不管反应式数据有多大，都会在启动时被观察到。如果你的数据集很大，这可能会在应用启动时带来明显的开销。在 3.x 中，只观察用于渲染应用程序最初可见部分的数据。</li>
<li>更精确的变更通知。在 2.x 中，通过 Vue.set 强制添加新属性将导致依赖于该对象的 watcher 收到变更通知。在 3.x 中，只有依赖于特定属性的 watcher 才会收到通知。</li>
<li>不可变的 observable：我们可以创建值的“不可变”版本（即使是嵌套属性），除非系统在内部暂时将其“解禁”。这个机制可用于冻结 prop 传递或 Vuex 状态树以外的变化。</li>
<li>更好的调试功能：我们可以使用新的 renderTracked 和 renderTriggered 钩子精确地跟踪组件在什么时候以及为什么重新渲染。</li>
</ul>
<p><strong>（2）模板</strong></p>
<p>模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。</p>
<p>同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。</p>
<p><strong>（3）对象式的组件声明方式</strong></p>
<p>vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。</p>
<p>3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易。</p>
<p>此外，vue 的源码也改用了 TypeScript 来写。其实当代码的功能复杂之后，必须有一个静态类型系统来做一些辅助管理。</p>
<p>现在 vue3.0 也全面改用 TypeScript 来重写了，更是使得对外暴露的 api 更容易结合 TypeScript。静态类型系统对于复杂代码的维护确实很有必要。</p>
<p><strong>（4）其它方面的更改</strong></p>
<p>vue3.0 的改变是全面的，上面只涉及到主要的 3 个方面，还有一些其他的更改：</p>
<ul>
<li>支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。</li>
<li>支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。</li>
<li>基于 treeshaking 优化，提供了更多的内置功能。</li>
</ul>
<h2 id="30、说说你使用-Vue-框架踩过最大的坑是什么？怎么解决的？"><a href="#30、说说你使用-Vue-框架踩过最大的坑是什么？怎么解决的？" class="headerlink" title="30、说说你使用 Vue 框架踩过最大的坑是什么？怎么解决的？"></a><strong>30、说说你使用 Vue 框架踩过最大的坑是什么？怎么解决的？</strong></h2><p>本题为开放题目，欢迎大家在评论区畅所欲言，分享自己的踩坑、填坑经历，提供前车之鉴，避免大伙再次踩坑 <del>~</del></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://supertinypeanut.github.io/blog/2020/02/12/vueInterView/" data-id="ckmm8vaaf002c85qs7slf75rv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Vue/" rel="tag">Vue</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-cross-storage" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/02/09/cross-storage/" class="article-date">
  <time datetime="2020-02-09T15:30:56.000Z" itemprop="datePublished">2020-02-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/02/09/cross-storage/">实现跨域存储</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="本地存储受同源策略限制"><a href="#本地存储受同源策略限制" class="headerlink" title="本地存储受同源策略限制"></a>本地存储受同源策略限制</h5><p>客户端（浏览器）出于安全性考虑，无论是 <code>localStorage</code> 还是 <code>sessionStorage</code> 都会受到同源策略限制。</p>
<p>那么如何实现<strong>跨域存储</strong>呢？</p>
<h5 id="window-postMessage"><a href="#window-postMessage" class="headerlink" title="window.postMessage()"></a>window.postMessage()</h5><p>想要实现<strong>跨域存储</strong>，先找到一种可跨域通信的机制，没错，就是 <code>postMessage</code>，它可以安全的实现跨域通信，不受同源策略限制。</p>
<p>语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otherWindow.postMessage(<span class="string">'message'</span>, targetOrigin, [transfer])</span><br></pre></td></tr></table></figure>

<ul>
<li><code>otherWindow</code> 窗口的一个引用，如：<code>iframe</code> 的 <code>contentWindow</code> 属性，当前 <code>window</code> 对象，<code>window.open</code> 返回的窗口对象等</li>
<li><code>message</code> 将要发送到 <code>otherWindow</code> 的数据</li>
<li><code>targetOrigin</code> 通过窗口的 <code>targetOrigin</code> 属性来指定哪些窗口能接收到消息事件，其值可以是字符串 <code>&quot;*&quot;</code>（表示无限制）</li>
</ul>
<h5 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h5><p>用 <code>postMessage</code> 可跨域特性，来实现跨域存储。因为多个不同域下的页面无法共享本地存储数据，我们需要找个“中转页面”来统一处理其它页面的存储数据。为了方便理解，画了张时序图，如下：</p>
<p><img src="/blog/.io//640.png" alt="img"></p>
<p>​                                                                 跨域存储时序图</p>
<h5 id="场景模拟"><a href="#场景模拟" class="headerlink" title="场景模拟"></a>场景模拟</h5><p><strong>需求：</strong></p>
<p>有两个不同的域名（<code>http://localhost:6001</code> 和 <code>http://localhost:6002</code>）想共用本地存储中的同一个 <code>token 作为统一登录凭证：</code></p>
<p><strong>假设：</strong></p>
<p><a href="http://localhost:6001" target="_blank" rel="noopener">http://localhost:6001</a> 对应 client1.html 页面</p>
<p><a href="http://localhost:6002" target="_blank" rel="noopener">http://localhost:6002</a> 对应 client2.html 页面</p>
<p><a href="http://localhost:6003" target="_blank" rel="noopener">http://localhost:6003</a> 对应 hub.html 中转页面</p>
<p><strong>启动服务：</strong></p>
<p>使用 <code>http-server</code> 启动 3 个本地服务</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm -g <span class="keyword">install</span> <span class="keyword">http</span>-<span class="keyword">server</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 3 个不同端口的服务，模拟跨域现象</span></span><br><span class="line"><span class="keyword">http</span>-<span class="keyword">server</span> -p <span class="number">6001</span></span><br><span class="line"><span class="keyword">http</span>-<span class="keyword">server</span> -p <span class="number">6002</span></span><br><span class="line"><span class="keyword">http</span>-<span class="keyword">server</span> -p <span class="number">6003</span></span><br></pre></td></tr></table></figure>

<h5 id="简单实现版本"><a href="#简单实现版本" class="headerlink" title="简单实现版本"></a>简单实现版本</h5><p><strong>client1.html 页面代码</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;!-- 开始存储事件 --&gt;</span><br><span class="line">  &lt;button onclick=<span class="string">"handleSetItem()"</span>&gt;client1-setItem&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;!-- iframe 嵌套“中转页面” hub.html --&gt;</span></span><br><span class="line"><span class="regexp">  &lt;iframe src="http:/</span><span class="regexp">/localhost:6003/</span>hub.html<span class="string">" frameborder="</span><span class="number">0</span><span class="string">" id="</span>hub<span class="string">"&gt;&lt;/iframe&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &lt;script&gt;</span></span><br><span class="line"><span class="string">    const $ = id =&gt; document.querySelector(id)</span></span><br><span class="line"><span class="string">    // 获取 iframe window 对象</span></span><br><span class="line"><span class="string">    const ifameWin = $('#hub').contentWindow</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    let count = 0</span></span><br><span class="line"><span class="string">    function handleSetItem () &#123;</span></span><br><span class="line"><span class="string">      let request = &#123;</span></span><br><span class="line"><span class="string">        // 存储的方法</span></span><br><span class="line"><span class="string">        method: 'setItem',</span></span><br><span class="line"><span class="string">        // 存储的 key</span></span><br><span class="line"><span class="string">        key: 'someKey',</span></span><br><span class="line"><span class="string">        // 需要存储的数据值</span></span><br><span class="line"><span class="string">        value: `来自 client-1 消息：$&#123;count++&#125;`,</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      // 向 iframe “中转页面”发送消息</span></span><br><span class="line"><span class="string">      ifameWin.postMessage(request, '*')</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>hub.html 中转页面代码</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="comment">// 映射关系</span></span><br><span class="line">    <span class="keyword">let</span> map = &#123;</span><br><span class="line">      setItem: <span class="function">(<span class="params">key, value</span>) =&gt;</span> <span class="built_in">window</span>.localStorage[<span class="string">'setItem'</span>](key, value <span class="string">"'setItem'"</span>),</span><br><span class="line">      getItem: <span class="function">(<span class="params">key</span>) =&gt;</span> <span class="built_in">window</span>.localStorage[<span class="string">'getItem'</span>](key <span class="string">"'getItem'"</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// “中转页面”监听 ifameWin.postMessage() 事件</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> &#123; method, key, value &#125; = e.data</span><br><span class="line">      <span class="comment">// 处理对应的存储方法</span></span><br><span class="line">      <span class="keyword">let</span> result = map[method](key, value <span class="string">"method"</span>)</span><br><span class="line">      <span class="comment">// 返回给当前 client 的数据</span></span><br><span class="line">      <span class="keyword">let</span> response = &#123;</span><br><span class="line">        result,</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 把获取的数据，传递给 client 窗口</span></span><br><span class="line">      <span class="built_in">window</span>.parent.postMessage(response, <span class="string">'*'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure>

<p><strong>client2.html 页面代码</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;!-- 获取本地存储数据 --&gt;</span><br><span class="line">  &lt;button onclick=<span class="string">"handleGetItem()"</span>&gt;client2-getItem&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;!-- iframe 嵌套“中转页面” hub.html --&gt;</span></span><br><span class="line"><span class="regexp">  &lt;iframe src="http:/</span><span class="regexp">/localhost:6003/</span>hub.html<span class="string">" frameborder="</span><span class="number">0</span><span class="string">" id="</span>hub<span class="string">"&gt;&lt;/iframe&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &lt;script&gt;</span></span><br><span class="line"><span class="string">    const $ = id =&gt; document.querySelector(id)</span></span><br><span class="line"><span class="string">    // 获取 iframe window 对象</span></span><br><span class="line"><span class="string">    const ifameWin = $('#hub').contentWindow</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    function handleGetItem () &#123;</span></span><br><span class="line"><span class="string">      let request = &#123;</span></span><br><span class="line"><span class="string">        // 存储的方法（获取）</span></span><br><span class="line"><span class="string">        method: 'getItem',</span></span><br><span class="line"><span class="string">        // 获取的 key</span></span><br><span class="line"><span class="string">        key: 'someKey',</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      // 向 iframe “中转页面”发送消息</span></span><br><span class="line"><span class="string">      ifameWin.postMessage(request, '*')</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 监听 iframe “中转页面”返回的消息</span></span><br><span class="line"><span class="string">    window.addEventListener('message', function (e) &#123;</span></span><br><span class="line"><span class="string">      console.log('client 2 获取到数据啦：', e.data)</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string">  &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>浏览器打开如下地址：</strong></p>
<ul>
<li><a href="http://localhost:6001/client1.html" target="_blank" rel="noopener">http://localhost:6001/client1.html</a></li>
<li><a href="http://localhost:6002/client2.html" target="_blank" rel="noopener">http://localhost:6002/client2.html</a></li>
</ul>
<p><strong>改进版本</strong></p>
<p>共拆分成 2 个 js 文件，一个是客户端页面使用 <code>client.js</code>，另一个是中转页面使用 <code>hub.js，具体代码如下：</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client.js</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (hubUrl) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hubUrl = hubUrl</span><br><span class="line">    <span class="comment">// 每个请求的 id 值，作为唯一标识（累加）</span></span><br><span class="line">    <span class="keyword">this</span>.id = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 所有请求消息数据映射（如：getItem、setItem）</span></span><br><span class="line">    <span class="keyword">this</span>._requests = &#123;&#125;</span><br><span class="line">    <span class="comment">// 获取 iframe window 对象</span></span><br><span class="line">    <span class="keyword">this</span>._iframeWin = <span class="keyword">this</span>._createIframe(<span class="keyword">this</span>.hubUrl).contentWindow</span><br><span class="line">    <span class="keyword">this</span>._initListener()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取存储数据</span></span><br><span class="line">  getItem (key, callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>._requestFn(<span class="string">'getItem'</span>, &#123;</span><br><span class="line">      key,</span><br><span class="line">      callback,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新存储数据 </span></span><br><span class="line">  setItem (key, value, callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>._requestFn(<span class="string">'setItem'</span>, &#123;</span><br><span class="line">      key,</span><br><span class="line">      value,</span><br><span class="line">      callback,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  _requestFn (method, &#123; key, value, callback &#125;) &#123;</span><br><span class="line">    <span class="comment">// 发消息时，请求对象格式</span></span><br><span class="line">    <span class="keyword">let</span> req = &#123;</span><br><span class="line">      id: <span class="keyword">this</span>.id++,</span><br><span class="line">      method,</span><br><span class="line">      key,</span><br><span class="line">      value,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 请求唯一标识 id 和回调函数的映射</span></span><br><span class="line">    <span class="keyword">this</span>._requests[req.id] = callback</span><br><span class="line">    <span class="comment">// 向 iframe “中转页面”发送消息</span></span><br><span class="line">    <span class="keyword">this</span>._iframeWin.postMessage(req, <span class="string">'*'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化监听函数</span></span><br><span class="line">  _initListener () &#123;</span><br><span class="line">    <span class="comment">// 监听 iframe “中转页面”返回的消息</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, (e) =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> &#123; id, result &#125; = e.data</span><br><span class="line">      <span class="comment">// 找到“中转页面”的消息对应的回调函数</span></span><br><span class="line">      <span class="keyword">let</span> currentCallback = <span class="keyword">this</span>._requests[id]</span><br><span class="line">      <span class="keyword">if</span> (!currentCallback) <span class="keyword">return</span></span><br><span class="line">      <span class="comment">// 调用并返回数据</span></span><br><span class="line">      currentCallback(result)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建 iframe 标签</span></span><br><span class="line">  _createIframe (hubUrl) &#123;</span><br><span class="line">    <span class="keyword">const</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>)</span><br><span class="line">    iframe.src = hubUrl</span><br><span class="line">    iframe.style = <span class="string">'display: none;'</span></span><br><span class="line">    <span class="built_in">window</span>.document.body.appendChild(iframe)</span><br><span class="line">    <span class="keyword">return</span> iframe</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hub.js</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hub</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>._initListener()</span><br><span class="line">    <span class="keyword">this</span>.map = &#123;</span><br><span class="line">      setItem: <span class="function">(<span class="params">key, value</span>) =&gt;</span> <span class="built_in">window</span>.localStorage[<span class="string">'setItem'</span>](key, value <span class="string">"'setItem'"</span>),</span><br><span class="line">      getItem: <span class="function">(<span class="params">key</span>) =&gt;</span> <span class="built_in">window</span>.localStorage[<span class="string">'getItem'</span>](key <span class="string">"'getItem'"</span>),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 监听 client ifameWin.postMessage() 事件</span></span><br><span class="line">  _initListener () &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, (e) =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> &#123; method, key, value, id &#125; = e.data</span><br><span class="line">      <span class="comment">// 处理对应的存储方法</span></span><br><span class="line">      <span class="keyword">let</span> result = <span class="keyword">this</span>.map[method](key, value <span class="string">"method"</span>)</span><br><span class="line">      <span class="comment">// 返回给当前 client 的数据</span></span><br><span class="line">      <span class="keyword">let</span> response = &#123;</span><br><span class="line">        id,</span><br><span class="line">        result,</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 把获取的数据，发送给 client 窗口</span></span><br><span class="line">      <span class="built_in">window</span>.parent.postMessage(response, <span class="string">'*'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>页面使用：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- client1 页面代码 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;button onclick=<span class="string">"handleGetItem()"</span>&gt;client1-GetItem&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;button onclick="handleSetItem()"&gt;client1-SetItem&lt;/</span>button&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script src=<span class="string">"./lib/client.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">  &lt;script&gt;</span></span><br><span class="line"><span class="regexp">    const crossStorage = new Client('http:/</span><span class="regexp">/localhost:6003/</span>hub.html<span class="string">')</span></span><br><span class="line"><span class="string">    // 在 client1 中，获取 client2 存储的数据</span></span><br><span class="line"><span class="string">    function handleGetItem () &#123;</span></span><br><span class="line"><span class="string">      crossStorage.getItem('</span>client2Key<span class="string">', (result) =&gt; &#123;</span></span><br><span class="line"><span class="string">        console.log('</span>client<span class="number">-1</span> getItem result: <span class="string">', result)</span></span><br><span class="line"><span class="string">      &#125;)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // client1 本地存储</span></span><br><span class="line"><span class="string">    function handleSetItem () &#123;</span></span><br><span class="line"><span class="string">      crossStorage.setItem('</span>client1Key<span class="string">', '</span>client<span class="number">-1</span> value<span class="string">', (result) =&gt; &#123;</span></span><br><span class="line"><span class="string">        console.log('</span>client<span class="number">-1</span> 完成本地存储<span class="string">')</span></span><br><span class="line"><span class="string">      &#125;)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;!-- hub 页面代码 --&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">  &lt;script src="./lib/hub.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">  &lt;script&gt;</span></span><br><span class="line"><span class="string">    const hub = new Hub()</span></span><br><span class="line"><span class="string">  &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;!-- client2 页面代码 --&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">  &lt;button onclick="handleGetItem()"&gt;client2-GetItem&lt;/button&gt;</span></span><br><span class="line"><span class="string">  &lt;button onclick="handleSetItem()"&gt;client2-SetItem&lt;/button&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &lt;script src="./lib/client.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">  &lt;script&gt;</span></span><br><span class="line"><span class="string">    const crossStorage = new Client('</span>http:<span class="comment">//localhost:6003/hub.html')</span></span><br><span class="line">    <span class="comment">// 在 client2 中，获取 client1 存储的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleGetItem</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      crossStorage.getItem(<span class="string">'client1Key'</span>, (result) =&gt; &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'client-2 getItem result: '</span>, result)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// client2 本地存储</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleSetItem</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      crossStorage.setItem(<span class="string">'client2Key'</span>, <span class="string">'client-2 value'</span>, (result) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'client-2 完成本地存储'</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>以上就实现了跨域存储，也是 <strong>cross-storage</strong> 开源库的核心原理。通过 <code>window.postMessage()</code> api 跨域特性，再配合一个 “中转页面”，来完成所谓的“跨域存储”，实际上并没有真正的在浏览器端实现跨域存储，这是浏览器的限制，我们无法打破，只能用“曲线救国”的方式，变向来共享存储数据。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://supertinypeanut.github.io/blog/2020/02/09/cross-storage/" data-id="ckmm8va6z001p85qs3vgj292d" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-gitQuestion" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/02/09/gitQuestion/" class="article-date">
  <time datetime="2020-02-09T15:30:56.000Z" itemprop="datePublished">2020-02-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/02/09/gitQuestion/">Git的41 个 问答</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>1. 你最喜欢的 Git 命令是什么</strong></p>
<blockquote>
<p>个人比较喜欢 <code>git add -p.</code> 这增加了“补丁模式”的变化，这是一个内置的命令行程序。它遍历了每个更改，并要求确认是否要执行它们。</p>
<p>这个命令迫使咱们放慢速度并检查更改文件。作为开发人员，咱们有时常常急于提交，我自己也经常这样，做完运行 <code>git add .</code> 才发现把调试的代码也提交上去了。</p>
</blockquote>
<h4 id="2-为什么你更喜欢直接使用-git-命令"><a href="#2-为什么你更喜欢直接使用-git-命令" class="headerlink" title="2. 为什么你更喜欢直接使用 git 命令"></a><strong>2. 为什么你更喜欢直接使用 git 命令</strong></h4><blockquote>
<p>作为开发人员，咱们也经常使用其它命令来做其它事情，也不差用 <code>git</code> 的命令来做事。</p>
<p>此外，<code>git</code> 命令也是非常短的，非常容易学习，并且使用命令可以了解 <code>git</code> 的工作流程，这样也间接改进了开发工作流程。</p>
</blockquote>
<h4 id="3-如何使用-stage-命令"><a href="#3-如何使用-stage-命令" class="headerlink" title="3. 如何使用 stage 命令"></a><strong>3. 如何使用 <code>stage</code> 命令</strong></h4><blockquote>
<p><code>stage</code>是<code>add .</code>的内置别名。</p>
</blockquote>
<h4 id="4-如何在分支中保存更改并-checkout-到其他分支"><a href="#4-如何在分支中保存更改并-checkout-到其他分支" class="headerlink" title="4.如何在分支中保存更改并 checkout 到其他分支"></a><strong>4.如何在分支中保存更改并 <code>checkout</code> 到其他分支</strong></h4><blockquote>
<p>因此，可以使用 <code>git stash</code> 临时存储更改或提交 WIP,目的是要有未修改前的环境。就我个人而言，我更喜欢使用 WIP 提交而不是 <code>stash</code>，因为它们更容易引用和共享。</p>
<p><strong>WIP = Work in Progress</strong></p>
<p>研发中的代码想存储起来，但是又避免研发中的代码被合并，开发就会创建一个WIP的分支</p>
<p><strong>WIP MR</strong></p>
<p><strong>WIP MR</strong> 含义是 在工作过程中的合并请求，是一个我们在 GitLab 中避免 MR 在准备就绪前被合并的技术。只需要添加 <code>WIP:</code> 在 MR 的标题开头，它将不会被合并，除非你把 <code>WIP:</code> 删除。</p>
</blockquote>
<h4 id="5-什么时候使用-git-stash"><a href="#5-什么时候使用-git-stash" class="headerlink" title="5.什么时候使用 git stash"></a><strong>5.什么时候使用 git stash</strong></h4><blockquote>
<p>发现有一个类是多余的，想删掉它又担心以后需要查看它的代码，想保存它但又不想增加一个脏的提交。这时就可以考虑 <code>git stash</code>。</p>
</blockquote>
<h4 id="6-如何使用-git-命令"><a href="#6-如何使用-git-命令" class="headerlink" title="6.如何使用 git 命令"></a><strong>6.如何使用 git 命令</strong></h4><blockquote>
<p>对任何命令使用 <code>--help</code>选项，例如，<code>git stash --help</code>。</p>
</blockquote>
<h4 id="7-什么是“-git-flow”？"><a href="#7-什么是“-git-flow”？" class="headerlink" title="7. 什么是“ git flow”？"></a><strong>7. 什么是“ git flow”？</strong></h4><blockquote>
<p>Git Flow 定义了一个项目发布的分支模型，为管理具有预定发布周期的大型项目提供了一个健壮的框架，是由 Vincent Driessen 提出的一个 git 操作流程标准、解决当分支过多时 , 如何有效快速管理这些分支。</p>
</blockquote>
<h4 id="8-什么是-GitHub-flow-？"><a href="#8-什么是-GitHub-flow-？" class="headerlink" title="8.什么是 GitHub flow ？"></a><strong>8.什么是 GitHub flow ？</strong></h4><blockquote>
<p>GitHub flow，顾名思义，就是 GitHub 所推崇的 Workflow。（千万不要理解成 GitHub 上才能用的 Workflow）, 基本上，GitHub Flow 是<code>master/feature</code>分支工作流程的品牌名称。</p>
<p>GitHub flow 的核心优势在于其流程带来的自动化可能性，能够做到其它流程无法实现的检查过程，并极大简化开发团队的体力劳动，真正发挥自身的价值。</p>
</blockquote>
<h4 id="9-你更喜欢哪种分支策略"><a href="#9-你更喜欢哪种分支策略" class="headerlink" title="9.你更喜欢哪种分支策略?"></a><strong>9.你更喜欢哪种分支策略?</strong></h4><blockquote>
<p>大多数 Git项目都是 “Git flow”。这些项目中只有少数需要这种策略，通常是因为它是版本化的软件。</p>
<p><code>master/feature</code> 分支策略更易于管理，尤其是在刚入门时，如果需要，切换到 “<code>git flow</code>” 非常容易。</p>
</blockquote>
<h4 id="10-git-open-命令是做啥用的"><a href="#10-git-open-命令是做啥用的" class="headerlink" title="10. git open 命令是做啥用的"></a><strong>10. git open 命令是做啥用的</strong></h4><blockquote>
<p>这是一个单独的命令，可以作为 npm 包使用。</p>
</blockquote>
<h4 id="11-当在其他分支中添加的文件仍然在工作分支中显示为未跟踪或修改时，如何重置分支"><a href="#11-当在其他分支中添加的文件仍然在工作分支中显示为未跟踪或修改时，如何重置分支" class="headerlink" title="11.当在其他分支中添加的文件仍然在工作分支中显示为未跟踪或修改时，如何重置分支"></a><strong>11.当在其他分支中添加的文件仍然在工作分支中显示为未跟踪或修改时，如何重置分支</strong></h4><blockquote>
<p>这通常是“工作索引”不干净时切换分支的结果。</p>
<p>在 git 中没有内置的方法来纠正这一点。通常通过确保提示符有一个 “<code>status</code>” 指示符并在每次更改分支时运行诸如 <code>git status</code> 之类的命令来避免这种情况。这些习惯会让咱们尽早发现这些问题，这样就可以在新的分支上 <code>stash</code> 或 <code>commit</code> 这些更改。</p>
</blockquote>
<h4 id="12-如何重命名分支"><a href="#12-如何重命名分支" class="headerlink" title="12. 如何重命名分支?"></a><strong>12. 如何重命名分支?</strong></h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m <span class="keyword">current</span>-branch-<span class="type">name</span> <span class="built_in">new</span>-branch-<span class="type">name</span></span><br></pre></td></tr></table></figure>

<h4 id="13-如何使用-cherry-pick"><a href="#13-如何使用-cherry-pick" class="headerlink" title="13. 如何使用 cherry-pick"></a><strong>13. 如何使用 cherry-pick</strong></h4><blockquote>
<p><code>git cherry-pick [reference]</code> 请记住，这是一个重新应用的命令，因此它将更改提交 SHA。</p>
</blockquote>
<h4 id="14-如果从一个分支恢复-例如-HEAD-3-，是否可以再次返回到-HEAD-比如恢复上一次更新"><a href="#14-如果从一个分支恢复-例如-HEAD-3-，是否可以再次返回到-HEAD-比如恢复上一次更新" class="headerlink" title="14. 如果从一个分支恢复(例如 HEAD~3)，是否可以再次返回到 HEAD(比如恢复上一次更新)"></a><strong>14. 如果从一个分支恢复(例如 <code>HEAD~3</code>)，是否可以再次返回到 <code>HEAD</code>(比如恢复上一次更新)</strong></h4><blockquote>
<p>在这种情况下，通过运行 <code>git reset --hard HEAD~1</code> 立即撤消还原提交（即 <code>HEAD</code> 提交）。</p>
</blockquote>
<h4 id="15-什么时候使用-git-pull-和-git-fetch？"><a href="#15-什么时候使用-git-pull-和-git-fetch？" class="headerlink" title="15. 什么时候使用 git pull 和 git fetch？"></a><strong>15. 什么时候使用 <code>git pull</code> 和 <code>git fetch</code>？</strong></h4><blockquote>
<p><code>git pull</code>将下载提交到当前分支。记住，<code>git pull</code>实际上是 <code>fetch</code> 和 <code>merge</code> 命令的组合。</p>
<p><code>git fetch</code>将从远程获取最新的引用。</p>
<p>一个很好的类比是播客播放器或电子邮件客户端。咱们可能会检索最新的播客或电子邮件(<code>fetch</code>)，但实际上尚未在本地下载播客或电子邮件附件(<code>pull</code>)。</p>
</blockquote>
<h4 id="16-为什么有时需要使用-force-来强制提交更改"><a href="#16-为什么有时需要使用-force-来强制提交更改" class="headerlink" title="16. 为什么有时需要使用 --force 来强制提交更改"></a><strong>16. 为什么有时需要使用 <code>--force</code> 来强制提交更改</strong></h4><blockquote>
<p><code>rebase</code> 是一个可以重新提交的命令，它改变了 <code>SHA1</code> hash。如果是这样，本地提交历史将不再与其远程分支保持一致。</p>
<p>当这种情况发生时，<code>push</code> 会被拒绝。只有在被拒绝时，才应该考虑使用 <code>git push --force</code>。这样做将用本地提交历&gt;史覆盖远程提交历史。所以可以回过头来想想，想想为什么要使用 <code>--force</code>。</p>
</blockquote>
<h4 id="17-可以使用分支合并多个分支，然后将该分支发送给-master-吗？"><a href="#17-可以使用分支合并多个分支，然后将该分支发送给-master-吗？" class="headerlink" title="17. 可以使用分支合并多个分支，然后将该分支发送给 master 吗？"></a><strong>17. 可以使用分支合并多个分支，然后将该分支发送给 <code>master</code> 吗？</strong></h4><blockquote>
<p>当然可以，在大多数 git 工作流下，分支通常会累积来自多个其他分支的更改,最终这些分支会被合并到主分支。</p>
</blockquote>
<h4 id="18-应该从一个非常老的分支做一个-rebase-吗？"><a href="#18-应该从一个非常老的分支做一个-rebase-吗？" class="headerlink" title="18. 应该从一个非常老的分支做一个 rebase 吗？"></a><strong>18. 应该从一个非常老的分支做一个 <code>rebase</code> 吗？</strong></h4><blockquote>
<p>除非是迫不得已。</p>
<p>根据你的工作流，可以将旧的分支合并到主分支中。</p>
<p>如果你需要一个最新的分支，我更喜欢 <code>rebase</code>。它只提供更改且更清晰的历史记录，而不是来自其他分支或合并的提交。</p>
<p>然而，尽管总是可能的，但是使用 <code>rebase</code> 可能是一个痛苦的过程，因为每次提交都要重新应用。这可能会导致多重冲突。如果是这样，我通常使用<code>rebase --abort</code> 并使用 <code>merge</code> 来一次性解决所有冲突。</p>
</blockquote>
<h4 id="19-使用-rebase-i-时，squash-和-fixup-有什么区别"><a href="#19-使用-rebase-i-时，squash-和-fixup-有什么区别" class="headerlink" title="19. 使用 rebase -i 时，squash 和 fixup 有什么区别"></a><strong>19. 使用 <code>rebase -i</code> 时，<code>squash</code> 和 <code>fixup</code> 有什么区别</strong></h4><blockquote>
<p><code>squash</code> 和 fixup  结合两个提交。<code>squash</code> 暂停 <code>rebase</code> 进程，并允许咱们调整提交的消息。<code>fixup</code> 自动使用来自第一次提交的消息。</p>
</blockquote>
<h4 id="20-通常，当使用-master-重新建立功能分支时，对于每次提交都需要解决冲突？"><a href="#20-通常，当使用-master-重新建立功能分支时，对于每次提交都需要解决冲突？" class="headerlink" title="20. 通常，当使用 master 重新建立功能分支时，对于每次提交都需要解决冲突？"></a><strong>20. 通常，当使用 <code>master</code> 重新建立功能分支时，对于每次提交都需要解决冲突？</strong></h4><blockquote>
<p>是的。由于每次提交的更改都会在 <code>rebase</code> 期间重新应用，所以必须在冲突发生时解决它们。</p>
<p>这意味着在提交之前就已经有了提交冲突，如果没有正确地解决它，那么下面的许多提交也可能发生冲突。为了限制这一点，我经常使用 <code>rebase -i</code> 来压缩提交历史记录，以便更轻松地使用它。</p>
<p>如果许多提交之间仍然存在冲突，可以使用 <code>merge</code>。</p>
</blockquote>
<h4 id="21-在与-master-合并之前，有必要更新我的分支吗"><a href="#21-在与-master-合并之前，有必要更新我的分支吗" class="headerlink" title="21.在与 master 合并之前，有必要更新我的分支吗"></a><strong>21.在与 master 合并之前，有必要更新我的分支吗</strong></h4><p>根据你的工作流，可以将旧的分支合并到主分支中。如果你的工作流仅使用 “<code>fast-forward</code>“合并，那么有必要在合并之前更新你的分支。</p>
<p><strong>Git fast forward 提交</strong></p>
<p>多人协同开发，使用 Git 经常会看到警告信息包含术语：<code>fast forward</code>, 这是何义？</p>
<p>简单来说就是提交到远程中心仓库的代码必须是按照时间顺序的。比如 <code>A</code> 从中心仓库拿到代码后，对文件 <code>f</code> 进行了修改。然后 <code>push</code> 到中心仓库。</p>
<p><code>B</code> 在 <code>A</code> 之前就拿到了中心仓库的代码，在 <code>A push</code> 成功之后也对 <code>f</code> 文件进行了修改。这个时候 <code>B</code> 也运行 <code>push</code> 命令推送代码。</p>
<p>会收到一个类似下面的信息：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chenshu@sloop2:~/work/<span class="number">189</span>/appengine$ git pushTo </span><br><span class="line">ssh:<span class="comment">//csfreebird@10.112.18.189:29418/appengine.git ! [rejected]       </span></span><br><span class="line">master -&gt; master (non-fast-forward)error: failed to push some refs to </span><br><span class="line">'ssh:<span class="comment">//csfreebird@10.112.18.189:29418/appengine.git'To prevent you from losing </span></span><br><span class="line">history, non-fast-forward updates were rejectedMerge the remote changes (e<span class="variable">.g</span>. 'git </span><br><span class="line">pull') <span class="keyword">before</span> pushing again.  See the'Note about fast-forwards' section of 'git push --help' <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure>

<p>提醒你非快进方式的更新被拒绝了，需要先从中心仓库<code>pull</code>到最新版本，<code>merge</code>后再 <code>push</code>.</p>
<p><code>fast forward</code> 能够保证不会强制覆盖别人的代码，确保了多人协同开发。尽量不要使用 <code>non fast forward</code>方法提交代码。</p>
<h4 id="22-需要使用-GitKraken-这种可视化工具吗"><a href="#22-需要使用-GitKraken-这种可视化工具吗" class="headerlink" title="22. 需要使用 GitKraken 这种可视化工具吗"></a><strong>22. 需要使用 GitKraken 这种可视化工具吗</strong></h4><blockquote>
<p>我比较喜欢用命令方式使用 git，因为这使我能够完全控制管理变更，就像使用命令来改进我的开发过程一样。</p>
<p>当然，某些可视化操作(如管理分支和查看文件差异)在GUI中总是更好。我个人认为在合并过程中在浏览器中查看这些内容就足够了。</p>
</blockquote>
<h4 id="23-当提交已经被推送时，可以做一个-amend-修改吗？"><a href="#23-当提交已经被推送时，可以做一个-amend-修改吗？" class="headerlink" title="23. 当提交已经被推送时，可以做一个 --amend 修改吗？"></a><strong>23. 当提交已经被推送时，可以做一个 <code>--amend</code> 修改吗？</strong></h4><blockquote>
<p>可以，<code>git commit –amend</code> 既可以对上次提交的内容进行修改，也可以修改提交说明。</p>
</blockquote>
<h4 id="24-在做迭代内容时，当完成一个小功能需要先拉一个-pull-request-请求，还是都做完这个迭代内容后在拉一个-pull-request-请求"><a href="#24-在做迭代内容时，当完成一个小功能需要先拉一个-pull-request-请求，还是都做完这个迭代内容后在拉一个-pull-request-请求" class="headerlink" title="24.在做迭代内容时，当完成一个小功能需要先拉一个 pull request 请求，还是都做完这个迭代内容后在拉一个 pull request 请求"></a><strong>24.在做迭代内容时，当完成一个小功能需要先拉一个 <code>pull request</code> 请求，还是都做完这个迭代内容后在拉一个 <code>pull request</code> 请求</strong></h4><blockquote>
<p>咱们通常做法是，完成一个迭代的内容后在拉一个 <code>pull request</code>。然而，如果你某个任务上花了很长时间，先合并做的功能可能是有益的。这样做可以防止对分支的依赖或过时，所以做完一个拉一个<strong>请求</strong>，还是全部做完在拉一个<strong>请求</strong>，这决于你正在进行的更改的类型。</p>
</blockquote>
<h4 id="25-在将分支合并到-master-之前，需要先创建一个-release-分支吗？"><a href="#25-在将分支合并到-master-之前，需要先创建一个-release-分支吗？" class="headerlink" title="25. 在将分支合并到 master 之前，需要先创建一个 release 分支吗？"></a><strong>25. 在将分支合并到 <code>master</code> 之前，需要先创建一个 <code>release</code> 分支吗？</strong></h4><blockquote>
<p>这在很大程度上取决于你们公司的部署过程。创建 <code>release</code> 分支对于将多个分支的工作分组在一起并将它们合并到主分支之前进行整体测试是有益的。</p>
<p>由于源分支保持独立和未合并，所以在最后的合并中拥有更大的灵活性。</p>
</blockquote>
<h4 id="26-如何从-master-获取一些提交-比方说，我不想执行最后一次提交，而是进行一次-rebase。"><a href="#26-如何从-master-获取一些提交-比方说，我不想执行最后一次提交，而是进行一次-rebase。" class="headerlink" title="26. 如何从 master 获取一些提交?比方说，我不想执行最后一次提交，而是进行一次 rebase。"></a><strong>26. 如何从 master 获取一些提交?比方说，我不想执行最后一次提交，而是进行一次 <code>rebase</code>。</strong></h4><blockquote>
<p>假设 <code>master</code> 分支是咱们的主分支，咱们不希望有选择地从它的历史记录中提取提交，这会以后引起冲突。</p>
<p>咱们想要 <code>merge</code> 或 <code>rebase</code> 分支的所有更改。要从主分支之外的分支提取选择提交，可以使用 <code>git cherry-pick</code>。</p>
</blockquote>
<h4 id="27-如何在-git-终端配置颜色"><a href="#27-如何在-git-终端配置颜色" class="headerlink" title="27. 如何在 git 终端配置颜色"></a>27. 如何在 git 终端配置颜色</h4><p>默认情况 下git 是黑白的。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> color<span class="variable">.status</span> auto </span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> color<span class="variable">.diff</span> auto </span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> color<span class="variable">.branch</span> auto </span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> color<span class="variable">.interactive</span> auto</span><br></pre></td></tr></table></figure>

<p>配置之后，就有颜色了。</p>
<h4 id="28-有没有更好的命令来替代-git-push-force"><a href="#28-有没有更好的命令来替代-git-push-force" class="headerlink" title="28. 有没有更好的命令来替代 git push -force ?"></a>28. 有没有更好的命令来替代 git push -force ?</h4><blockquote>
<p>实际上，没有其他方法可以替代 <code>git push—force</code>。虽然这样，如果正确地使用 <code>merge</code> 或 <code>rebase</code> 更新分支，则无需使用 <code>git push --force</code>。</p>
<p>只有当你运行了更改本地提交历史的命令时，才应该使用 <code>git push --force</code>。</p>
</blockquote>
<h4 id="29-当我在-git-rebase-选择drop时，是否删除了与该提交相关的代码？"><a href="#29-当我在-git-rebase-选择drop时，是否删除了与该提交相关的代码？" class="headerlink" title="29. 当我在 git rebase - 选择drop时，是否删除了与该提交相关的代码？"></a>29. 当我在 <code>git rebase -</code> 选择<code>drop</code>时，是否删除了与该提交相关的代码？</h4><blockquote>
<p>是的。要恢复这段代码，需要在 <code>reflog</code> 的 <code>rebase</code> 之前找到一个状态。</p>
</blockquote>
<h4 id="30-如何自动跟踪远程分支"><a href="#30-如何自动跟踪远程分支" class="headerlink" title="30. 如何自动跟踪远程分支"></a>30. 如何自动跟踪远程分支</h4><blockquote>
<p>通常，当你 <code>checkout</code> 或创建分支时，Git 会自动设置分支跟踪。</p>
<p>如果没有，则可以在下一次使用以下命令进行更新时：<code>git push -u remote-name branch-name</code>。</p>
<p>或者可以使用以下命令显式设置它：<code>git branch --set-upstream-to = remote-name / branch-name</code></p>
</blockquote>
<h4 id="31-在-rebase-分支之前更新分支，是一个好的习惯吗？"><a href="#31-在-rebase-分支之前更新分支，是一个好的习惯吗？" class="headerlink" title="31. 在 rebase 分支之前更新分支，是一个好的习惯吗？"></a>31. 在 <code>rebase</code> 分支之前更新分支，是一个好的习惯吗？</h4><blockquote>
<p>我认为是这样的，原因很简单，用<code>git rebase -i</code> 组织或压缩提交，首先在更新过程中提供更多的上下文。</p>
</blockquote>
<h4 id="32-有没有一种方法可以将提交拆分为更多的提交（与-fixup-squash-相反）？"><a href="#32-有没有一种方法可以将提交拆分为更多的提交（与-fixup-squash-相反）？" class="headerlink" title="32. 有没有一种方法可以将提交拆分为更多的提交（与 fixup/squash 相反）？"></a>32. 有没有一种方法可以将提交拆分为更多的提交（与 <code>fixup/squash</code> 相反）？</h4><blockquote>
<p>可以在<code>rebase -i</code>过程中使用 <code>exec</code> 命令来尝试修改工作索引并拆分更改。还可以使用 <code>git reset</code> 来撤消最近的提交，并将它们的更改放入工作索引中，然后将它们的更改分离到新的提交中。</p>
</blockquote>
<h4 id="33-有没有办法查看已修复的提交？"><a href="#33-有没有办法查看已修复的提交？" class="headerlink" title="33.有没有办法查看已修复的提交？"></a>33.有没有办法查看已修复的提交？</h4><p><strong>git log</strong></p>
<p>查看日志，找到对应的修改记录，但是这种查找只能看到文件，而不是文件的内容。</p>
<p><strong>git blame 文件名</strong></p>
<p>查看这个文件的修改记录，默认显示整个文件，也可以通过参数 -L,来检查需要修改的某几行。</p>
<p>如果查看之前提交的内容可以使用 <code>git show commitId</code>。</p>
<h4 id="34-rebase-–skip-作用是啥？"><a href="#34-rebase-–skip-作用是啥？" class="headerlink" title="34. rebase –skip 作用是啥？"></a>34. rebase –skip 作用是啥？</h4><p>咱们知道 <code>rebase</code> 的过程首先会产生 <code>rebase</code> 分支（<code>master</code>）的备份，放到（no branch ）临时分支中。再将支线分支（branch）的每一次提交修改，以补丁的形式，一个个的重新应用到主干分支上。这个过程是一个循环应用补丁的过程，期间只要补丁产生冲突，就会停止循环，等待手动解决冲突。这个冲突指的是上一个合并后版本与补丁之间的冲突。</p>
<p><code>git rebase --skip</code> 命令，可以跳过某一次补丁（存在上一轮冲突的解决方案中，已经包含了这一轮的补丁内容，这样会使补丁无效，需要跳过），这个命令慎用。</p>
<h4 id="35-如何删除远程分支？"><a href="#35-如何删除远程分支？" class="headerlink" title="35. 如何删除远程分支？"></a>35. 如何删除远程分支？</h4><p>可以使用:<code>git push origin:branch-name-to-remove</code> 或使用 <code>-d</code>选项:g<code>it push -d origin someother -branch-2</code> 来删除远程分支。</p>
<p>要删除对远程分支的本地引用，可以运行:<code>git remote prune origin</code>。</p>
<h4 id="36-checkout-和-reset-有什么区别"><a href="#36-checkout-和-reset-有什么区别" class="headerlink" title="36. checkout 和 reset 有什么区别"></a>36. <code>checkout</code> 和 <code>reset</code> 有什么区别</h4><p>这两个命令都可以用来撤销更改。<code>checkout</code> 可能更健壮，因为它不仅允许撤消当前更改，而且还允许通过检索文件的旧版本撤消一组更改。</p>
<p>默认情况下，<code>reset</code>更适合于更改工作索引中更改的状态。因此，它实际上只处理当前的变化。</p>
<p><code>git checkout -- file</code>；撤销对工作区修改；这个命令是以最新的存储时间节点（add和commit）为参照，覆盖工作区对应文件<code>file</code>；这个命令改变的是工作区。</p>
<p><code>git reset HEAD -- file</code>；清空 <code>add</code> 命令向暂存区提交的关于 <code>file</code> 文件的修改（Ustage）；这个命令仅改变暂存区，并不改变工作区，这意味着在无任何其他操作的情况下，工作区中的实际文件同该命令运行之前无任何变化</p>
<h4 id="37-在正常的工作流程中应该避免使用哪些命令"><a href="#37-在正常的工作流程中应该避免使用哪些命令" class="headerlink" title="37. 在正常的工作流程中应该避免使用哪些命令"></a>37. 在正常的工作流程中应该避免使用哪些命令</h4><p>一些可能会破坏历史记录的内容，例如：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push origin <span class="keyword">master</span> <span class="title">-f</span> (千万不要这样做)</span><br><span class="line">git revert</span><br><span class="line">git cherry-pick (changes from <span class="literal">master</span>)</span><br></pre></td></tr></table></figure>

<p>在正常的工作流程下，尽量避免直接使用git merge，因为这通常是通过拉请求(pull requests)构建到流程中的。</p>
<h4 id="38-如果我有一个分支-B-指向另一个分支-A-，而我又有另一个分支-C-，它需要-A-和-B-及-mast-分支的代码，怎么个流程才能更新-C-？"><a href="#38-如果我有一个分支-B-指向另一个分支-A-，而我又有另一个分支-C-，它需要-A-和-B-及-mast-分支的代码，怎么个流程才能更新-C-？" class="headerlink" title="38. 如果我有一个分支(B)指向另一个分支(A)，而我又有另一个分支(C)，它需要(A)和(B)及 mast 分支的代码，怎么个流程才能更新(C)？"></a>38. 如果我有一个分支(B)指向另一个分支(A)，而我又有另一个分支(C)，它需要(A)和(B)及 mast 分支的代码，怎么个流程才能更新(C)？</h4><p>这取决于几件事：</p>
<p>如果 <code>A</code> 和 <code>B</code> 可以合并到 <code>master</code>，则可以将 <code>A</code> 和 <code>B</code> 合并到 <code>master</code> 中，然后用<code>master</code>的更新 <code>C</code>。</p>
<p>如果 <code>A</code> 和 <code>B</code> 不能合并到 <code>master</code>，可以简单地将 <code>B</code> 合并到 <code>C</code> 中，因为 <code>B</code> 已经包含了 <code>A</code> 的变更。</p>
<p>在极端的情况下，可以将 <code>A</code>、<code>B</code> 和 <code>master</code> 合并到 <code>C</code> 中。然而，为了避免冲突，合并的顺序可能很重要。</p>
<h4 id="39-你使用的别名有哪些"><a href="#39-你使用的别名有哪些" class="headerlink" title="39. 你使用的别名有哪些"></a>39. 你使用的别名有哪些</h4><p>我常用的一些 git 别名如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alias</span><span class="variable">.unstage</span> reset HEAD --</span><br><span class="line"><span class="keyword">alias</span><span class="variable">.append</span> commit --amend --no-edit</span><br><span class="line"><span class="keyword">alias</span><span class="variable">.wip</span> commit -m <span class="string">"WIP"</span></span><br><span class="line"><span class="keyword">alias</span><span class="variable">.logo</span> log --oneline</span><br><span class="line"><span class="keyword">alias</span><span class="variable">.lola</span> log --graph --oneline --decorate --all</span><br></pre></td></tr></table></figure>

<h4 id="40-鲜为人知的-git-命令有哪些？"><a href="#40-鲜为人知的-git-命令有哪些？" class="headerlink" title="40. 鲜为人知的 git 命令有哪些？"></a>40. 鲜为人知的 git 命令有哪些？</h4><p><code>git bisect</code> 是查找代码中存在的<code>bug</code>的救命工具。虽然只使用过几次，但它的精确度令人印象深刻，节省了大量时间。</p>
<p><code>git archive</code> 是用于打包一组更改的好工具。这有助于与第三方或 <code>mico-deployment</code> 共享工作。</p>
<p><code>git reflog</code> 可能是众所周知的，但值得一提，因为它提供了一种在出错时“撤消”命令的好方法。</p>
<h4 id="41-你能推荐一些关于Git的书籍吗"><a href="#41-你能推荐一些关于Git的书籍吗" class="headerlink" title="41. 你能推荐一些关于Git的书籍吗"></a>41. 你能推荐一些关于Git的书籍吗</h4><p>我建议至少阅读Pro Git的前三章。这些年来，每看到一遍，或多或少都有收获。</p>
<p>也不错。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://supertinypeanut.github.io/blog/2020/02/09/gitQuestion/" data-id="ckmm8va70001r85qsd7jo4eyv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Git/" rel="tag">Git</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-arrayNotRepeat" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/02/09/arrayNotRepeat/" class="article-date">
  <time datetime="2020-02-09T15:30:56.000Z" itemprop="datePublished">2020-02-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/02/09/arrayNotRepeat/">数组去重</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="双层-for-循环"><a href="#双层-for-循环" class="headerlink" title="双层 for 循环"></a>双层 for 循环</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distinct</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>, len=arr.length; i&lt;len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j=i+<span class="number">1</span>; j&lt;len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == arr[j]) &#123;</span><br><span class="line">                arr.splice(j, <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// splice 会改变数组长度，所以要将数组长度 len 和下标 j 减一</span></span><br><span class="line">                len--;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思想: 双重 for 循环是比较笨拙的方法，它实现的原理很简单：先定义一个包含原始数组第一个元素的数组，然后遍历原始数组，将原始数组中的每个元素与新数组中的每个元素进行比对，如果不重复则添加到新数组中，最后返回新数组；因为它的时间复杂度是<code>O(n^2)</code>，如果数组长度很大，<code>效率会很低</code>。</p>
<h4 id="Array-filter-加-indexOf"><a href="#Array-filter-加-indexOf" class="headerlink" title="Array.filter() 加 indexOf"></a>Array.filter() 加 indexOf</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distinct</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = a.concat(b);</span><br><span class="line">    <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">item, index</span>)=&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr.indexOf(item) === index</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思想: 利用indexOf检测元素在数组中第一次出现的位置是否和元素现在的位置相等，如果不等则说明该元素是重复元素</p>
<h4 id="Array-sort-加一行遍历冒泡-相邻元素去重"><a href="#Array-sort-加一行遍历冒泡-相邻元素去重" class="headerlink" title="Array.sort() 加一行遍历冒泡(相邻元素去重)"></a>Array.sort() 加一行遍历冒泡(相邻元素去重)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distinct</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = [];</span><br><span class="line">    <span class="keyword">var</span> sortedArray = array.concat().sort();</span><br><span class="line">    <span class="keyword">var</span> seen;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = sortedArray.length; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果是第一个元素或者相邻的元素不相同</span></span><br><span class="line">        <span class="keyword">if</span> (!i || seen !== sortedArray[i]) &#123;</span><br><span class="line">            res.push(sortedArray[i])</span><br><span class="line">        &#125;</span><br><span class="line">        seen = sortedArray[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思想: 调用了数组的排序方法 <code>sort()</code>，V8引擎 的 sort() 方法在数组长度小于等于10的情况下，会使用插入排序，大于10的情况下会使用快速排序(sort函数在我之前高阶函数那篇文章有详细讲解)。然后根据排序后的结果进行遍历及相邻元素比对(其实就是一行冒泡排序比较)，如果相等则跳过该元素，直到遍历结束。</p>
<h4 id="ES6-中的-Set-去重"><a href="#ES6-中的-Set-去重" class="headerlink" title="ES6 中的 Set 去重"></a>ES6 中的 Set 去重</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distinct</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>甚至可以再简化下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [...new <span class="built_in">Set</span>(array)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以再简化下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unique = <span class="function">(<span class="params">a</span>) =&gt;</span> [...new <span class="built_in">Set</span>(a)]</span><br></pre></td></tr></table></figure>

<p>思想: ES6 提供了新的数据结构 Set，Set 结构的一个特性就是成员值都是唯一的，没有重复的值。(同时请大家注意这个简化过程)</p>
<h4 id="Object-键值对"><a href="#Object-键值对" class="headerlink" title="Object 键值对"></a>Object 键值对</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distinct</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> array.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj.hasOwnProperty(<span class="keyword">typeof</span> item + item) ? <span class="literal">false</span> : (obj[<span class="keyword">typeof</span> item + item] = <span class="literal">true</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法是利用一个空的 Object 对象，我们把数组的值存成 Object 的 key 值，比如 <code>Object[value1] = true</code>，在判断另一个值的时候，如果 Object[value2]存在的话，就说明该值是重复的,但是最后请注意这里<code>obj[typeof item + item] = true</code>没有直接使用<code>obj[item]</code>,是因为 123 和 ‘123’ 是不同的，直接使用前面的方法会判断为同一个值，因为<code>对象的键值只能是字符串</code>，所以我们可以使用 <code>typeof item + item</code> 拼成字符串作为 key 值来避免这个问题。</p>
<h3 id="性能考虑-是想要最快的速度查到数据吗？"><a href="#性能考虑-是想要最快的速度查到数据吗？" class="headerlink" title="性能考虑(是想要最快的速度查到数据吗？)"></a>性能考虑(是想要最快的速度查到数据吗？)</h3><p>为了测试这些解法的性能，我写了一个测试模版，用来计算数组去重的耗时。模版代码如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// distinct.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100000</span>), (x, index)=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> index</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">50000</span>), (x, index)=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> index+index</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'开始数组去重'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = a.concat(b);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distinct</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 数组去重</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'去重后的长度'</span>, distinct(arr).length)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> end = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'耗时'</span>, end - start)</span><br></pre></td></tr></table></figure>

<p>上面的多种数组去后，计算耗费时间</p>
<p><strong>双重 for 循环 &gt;  Array.filter()加 indexOf  &gt; Array.sort() 加一行遍历冒泡 &gt; ES6中的Set去重 &gt; Object 键值对去重复</strong></p>
<h3 id="兼容性与场景考虑-数组中是否包含对象，NaN等？"><a href="#兼容性与场景考虑-数组中是否包含对象，NaN等？" class="headerlink" title="兼容性与场景考虑(数组中是否包含对象，NaN等？)"></a>兼容性与场景考虑(数组中是否包含对象，NaN等？)</h3><p>我们要考虑这个数组中是否有null、undefined、NaN、对象如果二者都出现，上面的所有数组去重方法并不是都是适用哦，下面详细说一下。</p>
<h4 id="先说一下-和-区别"><a href="#先说一下-和-区别" class="headerlink" title="先说一下 == 和 === 区别"></a>先说一下 == 和 === 区别</h4><p><code>===</code> 严格相等，会比较两个值的类型和值<code>==</code> 抽象相等，比较时，会先进行类型转换，然后再比较值 想更详细了解转换过程的可以看这篇文章js 中 == 和 === 的区别</p>
<h4 id="说一下我说的几个类型的相等问题"><a href="#说一下我说的几个类型的相等问题" class="headerlink" title="说一下我说的几个类型的相等问题"></a>说一下我说的几个类型的相等问题</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">'123'</span>;</span><br><span class="line"><span class="keyword">let</span> str2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'123'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str1 == str2); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(str1 === str2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> == <span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> === <span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> == <span class="literal">undefined</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> === <span class="literal">undefined</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/a/</span> == <span class="regexp">/a/</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/a/</span> === <span class="regexp">/a/</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; == &#123;&#125;); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; === &#123;&#125;); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="几种去重函数针对带有特殊类型的对比"><a href="#几种去重函数针对带有特殊类型的对比" class="headerlink" title="几种去重函数针对带有特殊类型的对比"></a>几种去重函数针对带有特殊类型的对比</h4><p><strong>indexOf 与 Set 的一点说明</strong>：</p>
<p>上面代码中<code>console.log(NaN === NaN); // false</code>, indexOf 底层使用的是 === 进行判断，所以使用 indexOf 查找不到 NaN 元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo1</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>];</span><br><span class="line">arr.indexOf(<span class="literal">NaN</span>); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<p>Set可以去重NaN类型， Set内部认为尽管 NaN === NaN 为 false，但是这两个元素是重复的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distinct</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(unique([<span class="literal">NaN</span>, <span class="literal">NaN</span>])) <span class="comment">// [NaN]</span></span><br></pre></td></tr></table></figure>

<h4 id="具体去重比较"><a href="#具体去重比较" class="headerlink" title="具体去重比较"></a>具体去重比较</h4><p>将这样一个数组按照上面的方法去重后的比较：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'1'</span>), <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'1'</span>), /a/, /a/, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="right">结果</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">双层 for 循环</td>
<td align="right">[1, “1”, null, undefined, String, String, /a/, /a/, NaN, NaN]</td>
<td align="center">对象和 NaN 不去重</td>
</tr>
<tr>
<td align="left">Array.sort()加一行遍历冒泡</td>
<td align="right">[/a/, /a/, “1”, 1, String, 1, String, NaN, NaN, null, undefined]</td>
<td align="center">对象和 NaN 不去重 数字 1 也不去重</td>
</tr>
<tr>
<td align="left">Array.filter()加 indexOf</td>
<td align="right">[1, “1”, null, undefined, String, String, /a/, /a/]</td>
<td align="center">对象不去重 NaN 会被忽略掉</td>
</tr>
<tr>
<td align="left">Object 键值对去重</td>
<td align="right">[1, “1”, null, undefined, String, /a/, NaN]</td>
<td align="center"><strong>全部去重</strong></td>
</tr>
<tr>
<td align="left">ES6中的Set去重</td>
<td align="right">[1, “1”, null, undefined, String, String, /a/, /a/, NaN]</td>
<td align="center"><strong>对象不去重 NaN 去重</strong></td>
</tr>
</tbody></table>
<h3 id="内存考虑-去重复过程中，是想要空间复杂度最低吗？"><a href="#内存考虑-去重复过程中，是想要空间复杂度最低吗？" class="headerlink" title="内存考虑(去重复过程中，是想要空间复杂度最低吗？)"></a>内存考虑(去重复过程中，是想要空间复杂度最低吗？)</h3><p>虽然说对于 V8 引擎，内存考虑已经显得不那么重要了，而且真的数据量很大的时候，一般去重在后台处理了。尽管如此，我们也<code>不能放过任何一个可以证明自己优秀的</code>，还是考虑一下，嘿嘿。</p>
<p>以上的所有数组去重方式，应该 Object 对象去重复的方式是时间复杂度是最低的，除了一次遍历时间复杂度为<code>O(n)</code> 后，查找到重复数据的时间复杂度是<code>O(1)</code>，类似散列表，大家也可以使用 ES6 中的 Map 尝试实现一下。</p>
<p>但是对象去重复的空间复杂度是最高的，因为开辟了一个对象，其他的几种方式都没有开辟新的空间，从外表看来，更深入的源码有待探究，这里只是要说明大家在回答的时候也可以考虑到<code>时间复杂度</code>还有<code>空间复杂度</code>。</p>
<p>另外补充一个<strong>误区</strong>，有的小伙伴会认为 <code>Array.filter()</code>加 <code>indexOf</code> 这种方式时间复杂度为 <code>O(n)</code> ,其实不是这样，我觉得也是<code>O(n^2)</code>。因为 <code>indexOf</code> 函数，源码其实它也是进行 for 循环遍历的。具体实现如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.indexOf = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length - s.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.charAt(i) === s.charAt(<span class="number">0</span>) &amp;&amp;</span><br><span class="line">            <span class="keyword">this</span>.substring(i, s.length) === s) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="补充说明第三方库lodash"><a href="#补充说明第三方库lodash" class="headerlink" title="补充说明第三方库lodash"></a><strong>补充说明第三方库lodash</strong></h2><h3 id="lodash-如何实现去重"><a href="#lodash-如何实现去重" class="headerlink" title="lodash 如何实现去重"></a>lodash 如何实现去重</h3><p>简单说下 <code>lodash</code> 的 <code>uniq</code> 方法的源码实现。</p>
<p>这个方法的行为和使用 Set 进行去重的结果一致。</p>
<p>当数组长度大于等于 <code>200</code> 时，会创建 <code>Set</code>并将 <code>Set</code> 转换为数组来进行去重（Set 不存在情况的实现不做分析）。当数组长度小于 <code>200</code> 时，会使用类似前面提到的 双重循环 的去重方案，<strong>另外还会做 NaN 的去重</strong>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://supertinypeanut.github.io/blog/2020/02/09/arrayNotRepeat/" data-id="ckmm8va6w001l85qs642b0n6z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-designModel" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/02/08/designModel/" class="article-date">
  <time datetime="2020-02-08T15:53:00.000Z" itemprop="datePublished">2020-02-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/02/08/designModel/">常见javascript设计模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="模块设计模式"><a href="#模块设计模式" class="headerlink" title="模块设计模式"></a>模块设计模式</h5><p>JS 模块化是使用最普遍的设计模式，用于保持特殊的代码块与其它组件之间互相独立。为支持结构良好的代码提供了松耦合。</p>
<p>对于熟悉面向对象的开发者来说，模块就是 JS 的 “类”。封装是“类”的众多优点之一，可以确保它本身的状态和行为不被其它的类访问到。模块设计模式有公有和私有两种访问级别（除此之外，还有比较少为人知的保护级别、特权级别）。</p>
<p>考虑到私有的作用域，模块应该是一个立即调用函数（IIFE) ，也就是说，它是一个保护其私有变量和方法的闭包。（然而，它返回的却不是一个函数，而是一个对象）。</p>
<p>这种模式我们可以通过即行函数 IIFE（immediately-invoked function expression)、闭包和函数作用域来模拟，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myModule = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> privateVariable = <span class="string">"Hello World"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateMethod</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(privateVariable);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    publicMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      privateMethod();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">myModule.publicMethod();</span><br></pre></td></tr></table></figure>

<p>代码是即行函数的方法，通过立即执行函数，并把返回结果指向了 myModule 变量。由于闭包、返回的对象仍然可以访问定义在即行函数内的函数和变量，当然这些操作是在执行完即行函数产生实例之后了。我们可以看到，变量和方法被定义在即行函数内部，对于模块外部的作用域来说即达到了 private 的效果。</p>
<h5 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h5><p>工厂模式是一种使用工厂函数来创建对象的设计模式，该模式不用指定被创建对象准确的类或者构造函数。这种模式通常用来去创建一些不用暴露实例化逻辑的对象。例如我们可以根据依赖对象中传递的不同实例化条件来动态生成所需要的对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">this</span>.doors = options.doors || <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">this</span>.state = options.state || <span class="string">"brand new"</span>;</span><br><span class="line">    <span class="keyword">this</span>.color = options.color || <span class="string">"white"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Truck</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">this</span>.doors = options.doors || <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">this</span>.state = options.state || <span class="string">"used"</span>;</span><br><span class="line">    <span class="keyword">this</span>.color = options.color || <span class="string">"black"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VehicleFactory</span> </span>&#123;</span><br><span class="line">  createVehicle(options) &#123;</span><br><span class="line">    <span class="keyword">if</span> (options.vehicleType === <span class="string">"car"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Car(options);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options.vehicleType === <span class="string">"truck"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Truck(options);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我分别定义了一个 Car 和一个 Truck 类，并给对象添加了默认值，这 2 个类分别用来创建各自的 car 和 truck 对象。然后我定义了一个 VehicleFactory 类，根据 options 对象中 vehicleType 属性来创建和返回新的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> factory = <span class="keyword">new</span> VehicleFactory();</span><br><span class="line"><span class="keyword">const</span> car = factory.createVehicle(&#123;</span><br><span class="line">  vehicleType: <span class="string">"car"</span>,</span><br><span class="line">  doors: <span class="number">4</span>,</span><br><span class="line">  color: <span class="string">"silver"</span>,</span><br><span class="line">  state: <span class="string">"Brand New"</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> truck = factory.createVehicle(&#123;</span><br><span class="line">  vehicleType: <span class="string">"truck"</span>,</span><br><span class="line">  doors: <span class="number">2</span>,</span><br><span class="line">  color: <span class="string">"white"</span>,</span><br><span class="line">  state: <span class="string">"used"</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Prints Car &#123;doors: 4, state: "Brand New", color: "silver"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(car);</span><br><span class="line"><span class="comment">// Prints Truck &#123;doors: 2, state: "used", color: "white"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(truck);</span><br></pre></td></tr></table></figure>

<p>这里我用 VehicleFactory 类创建了一个工厂对象，然后分别指定两个 options 对象 vehicleType 属性的值为 car 和 truck，通过 factory.createVehicle 方法分别创建了 Car 和 Truck 对象。</p>
<h5 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h5><p>很多时候，当应用的一部分改变了，另一部分也需要相应更新。在 AngularJs 里面，如果 $scope 被更新，就会触发一个事件去通知其他组件。结合观察这模式就是：如果一个对象改变了，它只要派发 broadcasts 事件通知依赖的对象它已经改变了则可。</p>
<p>观察者模式主要应用于对象之间一对多的依赖关系，当一个对象发生改变时，多个对该对象有依赖的其他对象也会跟着做出相应改变，这就非常适合用观察者模式来实现。使用观察者模式可以根据需要增加或删除对象，解决一对多对象间的耦合关系，使程序更易于扩展和维护。</p>
<p>又一个典型的例子就是 model-view-controller (MVC) 架构了；当 model 改变时， 更新相应的 view。这样做有一个好处，就是从 model 上解耦出 view 来减少依赖。</p>
<p>实现一个观察者模式至少要包含 2 个角色如下图 UML 图中所示：Subject 和 Observer 对象 。</p>
<p><img src="/blog/.io//640.jpeg" alt="img"></p>
<p>下面我们使用 JavaScript 来实现上图的观察者模式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Subject = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> observers = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    subscribeObserver: <span class="function"><span class="keyword">function</span> (<span class="params">observer</span>) </span>&#123;</span><br><span class="line">      observers.push(observer);</span><br><span class="line">    &#125;,</span><br><span class="line">    unsubscribeObserver: <span class="function"><span class="keyword">function</span> (<span class="params">observer</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> index = observers.indexOf(observer);</span><br><span class="line">      <span class="keyword">if</span> (index &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        observers.splice(index, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    notifyObserver: <span class="function"><span class="keyword">function</span> (<span class="params">observer</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> index = observers.indexOf(observer);</span><br><span class="line">      <span class="keyword">if</span> (index &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        observers[index].notify(index);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    notifyAllObservers: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; observers.length; i++) &#123;</span><br><span class="line">        observers[i].notify(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Observer = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    notify: <span class="function"><span class="keyword">function</span> (<span class="params">index</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"Observer "</span> + index + <span class="string">" is notified!"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的代码我们实现了 Subject 对象，在其内部声明了一个 observers 数组用来存储注册的 observer 对象。下面让我们来使用这两个对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> subject = <span class="keyword">new</span> Subject();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> observer1 = <span class="keyword">new</span> Observer();</span><br><span class="line"><span class="keyword">var</span> observer2 = <span class="keyword">new</span> Observer();</span><br><span class="line"><span class="keyword">var</span> observer3 = <span class="keyword">new</span> Observer();</span><br><span class="line"><span class="keyword">var</span> observer4 = <span class="keyword">new</span> Observer();</span><br><span class="line"></span><br><span class="line">subject.subscribeObserver(observer1);</span><br><span class="line">subject.subscribeObserver(observer2);</span><br><span class="line">subject.subscribeObserver(observer3);</span><br><span class="line">subject.subscribeObserver(observer4);</span><br><span class="line"></span><br><span class="line">subject.notifyObserver(observer2); <span class="comment">// Observer 2 is notified!</span></span><br><span class="line"></span><br><span class="line">subject.notifyAllObservers();</span><br><span class="line"><span class="comment">// Observer 1 is notified!</span></span><br><span class="line"><span class="comment">// Observer 2 is notified!</span></span><br><span class="line"><span class="comment">// Observer 3 is notified!</span></span><br><span class="line"><span class="comment">// Observer 4 is notified!</span></span><br></pre></td></tr></table></figure>

<p>以上实现了一个简单的设计者模式，先使用 subjectsubscribeObserver(observer)注册以后要通知的观察者对象，当我们想通知注册好的观察者对象时，只需要使用 subject.notifyObserver(observer)即可</p>
<h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><p>单例模式只允许实例化一个对象，但是相同的对象，会用很多个实例。单例模式制约着客户端创建多个对象。第一个对象创建后，就返回实例本身。</p>
<p>JavaScript 语言本身就是支持单例模式的，不过我们一般并不称它为单例模式，我们通常叫它字面量对象，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  name: <span class="string">"Peter"</span>,</span><br><span class="line">  age: <span class="number">25</span>,</span><br><span class="line">  job: <span class="string">"Teacher"</span>,</span><br><span class="line">  greet: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Hello!"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>JavaScript 中的每个对象在内存中都是唯一的，当我们调用 User 对象时，实质上也是返回的对象引用地址。</p>
<p>假如我们想要拷贝某个对象到另外一个变量，并且修改变量，该如何办呢？如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user1 = user;</span><br><span class="line">user1.name = <span class="string">"Mark"</span>;</span><br></pre></td></tr></table></figure>

<p>我们会得到结果是两个对象的 name 都被修改了, 因为赋值的时候是引用赋值，而不是值赋值。所以内存中只有一份对象。请看：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// prints 'Mark'</span></span><br><span class="line"><span class="built_in">console</span>.log(user.name);</span><br><span class="line"><span class="comment">// prints 'Mark'</span></span><br><span class="line"><span class="built_in">console</span>.log(user1.name);</span><br><span class="line"><span class="comment">// prints true</span></span><br><span class="line"><span class="built_in">console</span>.log(user === user1);</span><br></pre></td></tr></table></figure>

<p>单例模式可以通过构造函数来实现，看代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> printer = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> printerInstance;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      turnOn: <span class="function"><span class="keyword">function</span> <span class="title">turnOn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"working"</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getInstance: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!printerInstance) &#123;</span><br><span class="line">        printerInstance = create();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> printerInstance;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">printer.getInstance().turnOn(); <span class="comment">// output: working</span></span><br></pre></td></tr></table></figure>

<p>从上面代码我们可以看到 printer 模块提供了一个唯一外部可以访问的接口 getInstance，当第一次访问该接口时，我们先判断实例是否被创建，如果没有创建则使用 create()创建，如果已经创建则返回唯一的实例 printerInstance。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://supertinypeanut.github.io/blog/2020/02/08/designModel/" data-id="ckmm8va53000b85qsa8p9c66g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-proceduralQuestions_1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/01/30/proceduralQuestions_1/" class="article-date">
  <time datetime="2020-01-30T10:10:10.000Z" itemprop="datePublished">2020-01-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/01/30/proceduralQuestions_1/">Promise实现两秒打印和函数柯理化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h6 id="promise实现两秒打印一次成功或失败（随机数大于0-5成功，反之失败）"><a href="#promise实现两秒打印一次成功或失败（随机数大于0-5成功，反之失败）" class="headerlink" title="promise实现两秒打印一次成功或失败（随机数大于0.5成功，反之失败）"></a>promise实现两秒打印一次成功或失败（随机数大于0.5成功，反之失败）</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setThreeSecond</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> promiseObj = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> s = <span class="built_in">Math</span>.random()</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">      resolve(<span class="string">'成功'</span> + s)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      reject(<span class="string">'失败'</span> + s)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  promiseObj.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">  &#125;, err =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setThreeSecond()</span><br></pre></td></tr></table></figure>



<h6 id="实现add-1-2-3-4-…累加器-柯里化"><a href="#实现add-1-2-3-4-…累加器-柯里化" class="headerlink" title="实现add(1)(2)(3)(4)…累加器(柯里化)"></a>实现add(1)(2)(3)(4)…累加器(柯里化)</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">s</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">temp</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(s + a)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  temp.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="https://supertinypeanut.github.io/blog/2020/01/30/proceduralQuestions_1/" data-id="ckmm8va5d000l85qs1x6o2qvq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/blog/page/2/">&amp;laquo; 上一页</a><a class="page-number" href="/blog/">1</a><a class="page-number" href="/blog/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/blog/page/4/">4</a><a class="extend next" rel="next" href="/blog/page/4/">下一页 &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/ECMAScript-6/" rel="tag">ECMAScript 6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Lint/" rel="tag">Lint</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/React/" rel="tag">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/TypeScript/" rel="tag">TypeScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Vue/" rel="tag">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Webpack/" rel="tag">Webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/npm/" rel="tag">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/web-%E5%AE%89%E5%85%A8/" rel="tag">web 安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/" rel="tag">前端工程化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" rel="tag">问题解决</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/ECMAScript-6/" style="font-size: 12.5px;">ECMAScript 6</a> <a href="/blog/tags/Git/" style="font-size: 15px;">Git</a> <a href="/blog/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/blog/tags/Lint/" style="font-size: 10px;">Lint</a> <a href="/blog/tags/React/" style="font-size: 12.5px;">React</a> <a href="/blog/tags/TypeScript/" style="font-size: 12.5px;">TypeScript</a> <a href="/blog/tags/Vue/" style="font-size: 17.5px;">Vue</a> <a href="/blog/tags/Webpack/" style="font-size: 10px;">Webpack</a> <a href="/blog/tags/npm/" style="font-size: 10px;">npm</a> <a href="/blog/tags/web-%E5%AE%89%E5%85%A8/" style="font-size: 15px;">web 安全</a> <a href="/blog/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/" style="font-size: 12.5px;">前端工程化</a> <a href="/blog/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" style="font-size: 15px;">问题解决</a> <a href="/blog/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 12.5px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2020/09/">九月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/11/">十一月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2021/03/23/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E4%B8%8E%E6%8C%81%E7%BB%AD%E9%83%A8%E7%BD%B2/">持续集成与持续部署</a>
          </li>
        
          <li>
            <a href="/blog/2021/03/07/Promise%E5%AE%9E%E7%8E%B0/">Promise实现</a>
          </li>
        
          <li>
            <a href="/blog/2021/03/03/ES6%E9%9D%A2%E8%AF%95%E9%A2%98/">ES6面试题</a>
          </li>
        
          <li>
            <a href="/blog/2021/01/25/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/">自动化测试</a>
          </li>
        
          <li>
            <a href="/blog/2020/12/27/async-validator%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">async-validator基本使用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Super Peanut<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">

  
<script src="/blog/fancybox/jquery.fancybox.pack.js"></script>




<script src="/blog/js/script.js"></script>




  </div>
</body>
</html>